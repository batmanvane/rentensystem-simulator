<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>Stable 3D LBM</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; }
        #info {
            position: absolute; top: 10px; width: 100%; text-align: center;
            color: #aaa; font-family: sans-serif; pointer-events: none;
            text-shadow: 1px 1px 2px black;
        }
    </style>
</head>
<body>
    <div id="info">3D LBM &bull; Stabilized<br>Touch & Drag to Rotate</div>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- CONFIG ---
        const SIZE = 32;
        const ATLAS_COLS = 8;
        const ATLAS_ROWS = 4;
        const RES_X = SIZE * ATLAS_COLS;
        const RES_Y = SIZE * ATLAS_ROWS;

        // --- SHADER COMMON ---
        const shaderCommon = `
            precision highp float;
            precision highp sampler2D;
            #define SIZE 32.0
            #define ATLAS_COLS 8.0
            #define RES_X 256.0
            #define RES_Y 128.0

            vec2 uv3Dto2D(vec3 uvw) {
                vec3 voxel = floor(uvw * SIZE);
                voxel = clamp(voxel, vec3(0.0), vec3(SIZE - 1.0));
                float zIndex = voxel.z;
                float col = mod(zIndex, ATLAS_COLS);
                float row = floor(zIndex / ATLAS_COLS);
                vec2 sliceOffset = vec2(col * SIZE, row * SIZE);
                vec2 pixelPos = sliceOffset + voxel.xy + 0.5;
                return pixelPos / vec2(RES_X, RES_Y);
            }
        `;

        // --- CONSTANTS (Weights) ---
        // Center: 2/9, Face: 1/9, Corner: 1/72
        const glslWeights = `
            const float w0 = 0.2222222; // 2/9
            const float w1 = 0.1111111; // 1/9
            const float w2 = 0.0138888; // 1/72
            // 0, 1-6, 7-14
        `;

        // --- INIT SHADER (Sets perfect equilibrium) ---
        const initFrag = `
            ${shaderCommon}
            ${glslWeights}
            layout(location = 0) out vec4 out0;
            layout(location = 1) out vec4 out1;
            layout(location = 2) out vec4 out2;
            layout(location = 3) out vec4 out3;

            void main() {
                // Initialize with Density = 1.0, Velocity = 0.0
                // f_i = w_i * rho
                out0 = vec4(w0, w1, w1, w1);      // 0, 1, 2, 3
                out1 = vec4(w1, w1, w1, w2);      // 4, 5, 6, 7
                out2 = vec4(w2, w2, w2, w2);      // 8, 9, 10, 11
                out3 = vec4(w2, w2, w2, 1.0);     // 12, 13, 14, unused
            }
        `;

        // --- SIMULATION SHADER ---
        const simFrag = `
            ${shaderCommon}
            ${glslWeights}
            
            uniform sampler2D t0, t1, t2, t3;
            uniform vec3 mouseVel;
            uniform float time;

            layout(location = 0) out vec4 out0;
            layout(location = 1) out vec4 out1;
            layout(location = 2) out vec4 out2;
            layout(location = 3) out vec4 out3;

            const vec3 e[15] = vec3[](
                vec3(0,0,0),
                vec3(1,0,0), vec3(-1,0,0), vec3(0,1,0), vec3(0,-1,0), vec3(0,0,1), vec3(0,0,-1),
                vec3(1,1,1), vec3(-1,1,1), vec3(1,-1,1), vec3(-1,-1,1),
                vec3(1,1,-1), vec3(-1,1,-1), vec3(1,-1,-1), vec3(-1,-1,-1)
            );

            const float weights[15] = float[](
                w0, w1, w1, w1, w1, w1, w1,
                w2, w2, w2, w2, w2, w2, w2, w2
            );

            void main() {
                vec2 uv = gl_FragCoord.xy / vec2(RES_X, RES_Y);
                
                // Reconstruct 3D pos
                float col = floor(gl_FragCoord.x / SIZE);
                float row = floor(gl_FragCoord.y / SIZE);
                float z = row * ATLAS_COLS + col;
                float x = mod(gl_FragCoord.x, SIZE);
                float y = mod(gl_FragCoord.y, SIZE);
                vec3 currentPos = vec3(x, y, z) / SIZE;

                // Stream
                float f[15];
                for(int i=0; i<15; i++) {
                    vec3 neighborPos = currentPos - (e[i] / SIZE);
                    vec2 sampleUV = uv3Dto2D(neighborPos);
                    vec4 s0 = texture(t0, sampleUV);
                    vec4 s1 = texture(t1, sampleUV);
                    vec4 s2 = texture(t2, sampleUV);
                    vec4 s3 = texture(t3, sampleUV);
                    
                    if(i==0) f[0]=s0.r; else if(i==1) f[1]=s0.g; else if(i==2) f[2]=s0.b; else if(i==3) f[3]=s0.a;
                    else if(i==4) f[4]=s1.r; else if(i==5) f[5]=s1.g; else if(i==6) f[6]=s1.b; else if(i==7) f[7]=s1.a;
                    else if(i==8) f[8]=s2.r; else if(i==9) f[9]=s2.g; else if(i==10) f[10]=s2.b; else if(i==11) f[11]=s2.a;
                    else if(i==12) f[12]=s3.r; else if(i==13) f[13]=s3.g; else if(i==14) f[14]=s3.b;
                }

                // Moments
                float rho = 0.0;
                vec3 u = vec3(0.0);
                for(int i=0; i<15; i++) {
                    rho += f[i];
                    u += e[i] * f[i];
                }
                
                // Hard Safety Clamp: Prevent division by zero or negative mass
                if(rho < 0.1) rho = 1.0; 
                
                u /= rho;

                // Input Injection (Gentle)
                float d = distance(currentPos, vec3(0.5));
                if(d < 0.15) {
                    u += mouseVel * 0.05; // Very weak injection
                }

                // Safety Clamp Velocity (The "Anti-Explosion" lock)
                if(length(u) > 0.1) u = normalize(u) * 0.1;

                // Collision (BGK)
                // Omega = 1.0 is very stable (Viscous). 
                float omega = 1.0; 
                float uSqu = dot(u, u);
                
                for(int i=0; i<15; i++) {
                    float eu = dot(e[i], u);
                    float feq = weights[i] * rho * (1.0 + 3.0*eu + 4.5*eu*eu - 1.5*uSqu);
                    f[i] = mix(f[i], feq, omega);
                }

                out0 = vec4(f[0], f[1], f[2], f[3]);
                out1 = vec4(f[4], f[5], f[6], f[7]);
                out2 = vec4(f[8], f[9], f[10], f[11]);
                out3 = vec4(f[12], f[13], f[14], 1.0);
            }
        `;

        // --- VISUALIZATION SHADER ---
        const sliceFrag = `
            ${shaderCommon}
            varying vec3 vPos;
            uniform sampler2D t0, t1, t2, t3;

            void main() {
                vec2 uv = uv3Dto2D(vPos);
                vec4 s0 = texture(t0, uv);
                vec4 s1 = texture(t1, uv);
                vec4 s2 = texture(t2, uv);
                vec4 s3 = texture(t3, uv);
                
                // Calculate Macroscopic Velocity Magnitude for color
                // (Showing speed is more interesting than density for incompressible fluid)
                // We just approximate velocity direction roughly
                // Or just show Density (rho)
                
                float rho = dot(s0, vec4(1.0)) + dot(s1, vec4(1.0)) + dot(s2, vec4(1.0)) + dot(s3.rgb, vec3(1.0));
                
                // Enhance contrast of small ripples
                float val = (rho - 1.0) * 15.0; // High contrast
                
                vec3 col = vec3(0.0, 0.0, 0.2);
                if(val > 0.0) col = mix(col, vec3(0.0, 1.0, 1.0), val);
                if(val < 0.0) col = mix(col, vec3(1.0, 0.0, 0.2), -val);

                float alpha = smoothstep(0.01, 0.2, abs(val)) * 0.8 + 0.1;
                gl_FragColor = vec4(col, alpha);
            }
        `;

        const sliceVert = `
            varying vec3 vPos;
            void main() {
                vPos = position + 0.5; 
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        // --- SETUP ---
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(1); // Performance
        document.body.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);
        camera.position.set(1.8, 1.8, 2.2);
        
        new OrbitControls(camera, renderer.domElement);

        // Targets
        const createTarget = () => new THREE.WebGLMultipleRenderTargets(
            RES_X, RES_Y, 4, 
            { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, type: THREE.FloatType }
        );
        let simA = createTarget();
        let simB = createTarget();

        // 1. INIT MESH
        const initMat = new THREE.ShaderMaterial({
            vertexShader: `void main() { gl_Position = vec4( position, 1.0 ); }`,
            fragmentShader: initFrag,
            glslVersion: THREE.GLSL3
        });
        const fsQuad = new THREE.Mesh(new THREE.PlaneGeometry(2,2), initMat);
        const simScene = new THREE.Scene();
        simScene.add(fsQuad);

        // Run Init
        renderer.setRenderTarget(simA);
        renderer.render(simScene, new THREE.Camera());
        renderer.setRenderTarget(simB); // Clear B too
        renderer.render(simScene, new THREE.Camera());

        // 2. SIM MESH
        const simMat = new THREE.ShaderMaterial({
            uniforms: {
                t0: { value: null }, t1: { value: null }, t2: { value: null }, t3: { value: null },
                mouseVel: { value: new THREE.Vector3(0,0,0) },
                time: { value: 0 }
            },
            vertexShader: `void main() { gl_Position = vec4( position, 1.0 ); }`,
            fragmentShader: simFrag,
            glslVersion: THREE.GLSL3
        });
        fsQuad.material = simMat; // Swap material

        // 3. VIS MESH
        const visMat = new THREE.ShaderMaterial({
            uniforms: { t0: { value: null }, t1: { value: null }, t2: { value: null }, t3: { value: null } },
            vertexShader: sliceVert, fragmentShader: sliceFrag,
            side: THREE.DoubleSide, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
        });
        const pg = new THREE.PlaneGeometry(1,1);
        const group = new THREE.Group();
        group.add(new THREE.Mesh(pg, visMat));
        const p2 = new THREE.Mesh(pg, visMat); p2.rotation.x = Math.PI/2; group.add(p2);
        const p3 = new THREE.Mesh(pg, visMat); p3.rotation.y = Math.PI/2; group.add(p3);
        scene.add(group);
        scene.add(new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.BoxGeometry(1,1,1)), new THREE.LineBasicMaterial({color:0x333333})));

        // --- LOOP ---
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();

            // Gentle Oscillation
            simMat.uniforms.mouseVel.value.set(Math.sin(t*2), Math.cos(t*1.5), 0);

            // Ping-Pong
            let source = simA, dest = simB;
            // We do 2 steps per frame for speed
            for(let i=0; i<2; i++) {
                simMat.uniforms.t0.value = source.texture[0];
                simMat.uniforms.t1.value = source.texture[1];
                simMat.uniforms.t2.value = source.texture[2];
                simMat.uniforms.t3.value = source.texture[3];
                
                renderer.setRenderTarget(dest);
                renderer.render(simScene, new THREE.Camera());
                
                // Swap
                let temp = source; source = dest; dest = temp;
            }
            simA = source; simB = dest;

            // Render
            renderer.setRenderTarget(null);
            visMat.uniforms.t0.value = simA.texture[0];
            visMat.uniforms.t1.value = simA.texture[1];
            visMat.uniforms.t2.value = simA.texture[2];
            visMat.uniforms.t3.value = simA.texture[3];
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>