<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Perturbed Liquid Torus</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; user-select: none; }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            background: rgba(0,0,0,0.6); color: white; z-index: 10;
            flex-direction: column; text-align: center; backdrop-filter: blur(5px);
        }
        h1 { margin-bottom: 5px; font-weight: 300; letter-spacing: 2px; }
        p { color: #aaa; font-size: 14px; margin-bottom: 30px; }
        button {
            padding: 18px 40px; font-size: 16px; background: white;
            border: none; border-radius: 30px; color: #000; cursor: pointer; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.3); transition: transform 0.1s;
            font-weight: 600; text-transform: uppercase; letter-spacing: 1px;
        }
        button:active { transform: scale(0.95); }
        #viscosity-label {
            position: absolute; top: 30px; width: 100%; text-align: center;
            color: rgba(255,255,255,0.8); pointer-events: none; font-size: 16px;
            font-weight: 300; letter-spacing: 4px; text-transform: uppercase;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
            transition: color 0.3s;
        }
        #hint { 
            position: absolute; bottom: 30px; width: 100%; text-align: center; 
            color: rgba(255,255,255,0.3); pointer-events: none; font-size: 12px;
            text-transform: uppercase; letter-spacing: 2px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

<div id="viscosity-label">WATER</div>
<div id="hint">Move to Splash • Tilt to Warp • Drag to Thicken</div>

<div id="overlay">
    <div>
        <h1>LIQUID TORUS</h1>
        <p>Motion Perturbation Demo</p>
        <button id="startBtn">Start</button>
    </div>
</div>

<script>
    // --- CONFIGURATION ---
    const NX = 100; // Resolution around major axis
    const NY = 50;  // Resolution around tube
    const Q = 9; 
    
    // Torus Base Geometry
    let majorRadius = 30; 
    let minorRadius = 12;

    // Dynamics
    let viscosity = 0.02; 
    let omega = 1.0 / (3.0 * viscosity + 0.5);
    let running = false;

    // --- LBM VARIABLES ---
    const SIZE = NX * NY * Q;
    let f = new Float32Array(SIZE);
    let f_new = new Float32Array(SIZE);
    let rho = new Float32Array(NX * NY); 
    
    const w = [4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36];
    const cx = [0, 1, 0, -1, 0, 1, -1, -1, 1];
    const cy = [0, 0, 1, 0, -1, 1, 1, -1, -1];
    const opposite = [0, 3, 4, 1, 2, 7, 8, 5, 6]; 

    // Physics Inputs
    let forceX = 0.0;
    let forceY = 0.0;
    let tiltX = 0.0; // Deforms geometry
    let tiltY = 0.0;
    let shakeEnergy = 0.0; // Random perturbations

    // --- 1. INITIALIZATION ---
    function initLBM() {
        for (let y = 0; y < NY; y++) {
            for (let x = 0; x < NX; x++) {
                const idx = y * NX + x;
                let initialRho = 1.0;
                // Tiny noise to start
                if (Math.random() > 0.99) initialRho += 0.5; 
                rho[idx] = initialRho;
                for (let i = 0; i < Q; i++) f[idx * Q + i] = w[i] * initialRho;
            }
        }
    }

    // --- 2. PHYSICS LOOP (Periodic) ---
    function stepLBM() {
        
        // Dampen the shake energy over time
        shakeEnergy *= 0.9;
        // Dampen forces (friction)
        forceX *= 0.95;
        forceY *= 0.95;

        for (let y = 0; y < NY; y++) {
            for (let x = 0; x < NX; x++) {
                const idx = y * NX + x;
                
                let sumRho = 0;
                let sumUx = 0;
                let sumUy = 0;

                for (let i = 0; i < Q; i++) {
                    const fi = f[idx * Q + i];
                    sumRho += fi;
                    sumUx += fi * cx[i];
                    sumUy += fi * cy[i];
                }

                // --- PERTURBATION LOGIC ---
                // If shaking, inject random density noise to create ripples
                if (shakeEnergy > 0.01 && Math.random() < 0.01) {
                    sumRho += (Math.random() - 0.5) * shakeEnergy * 5.0;
                }

                rho[idx] = sumRho;
                
                // Add External Motion Forces (Inertia)
                sumUx += forceX * sumRho;
                sumUy += forceY * sumRho;

                const localUx = sumUx / sumRho;
                const localUy = sumUy / sumRho;
                const u2 = localUx * localUx + localUy * localUy;

                for (let i = 0; i < Q; i++) {
                    const cidotU = cx[i] * localUx + cy[i] * localUy;
                    const feq = w[i] * sumRho * (1 + 3 * cidotU + 4.5 * cidotU * cidotU - 1.5 * u2);
                    const postCollision = f[idx * Q + i] * (1 - omega) + feq * omega;

                    // Periodic Wrap-around
                    let nextX = (x + cx[i] + NX) % NX;
                    let nextY = (y + cy[i] + NY) % NY;

                    f_new[(nextY * NX + nextX) * Q + i] = postCollision;
                }
            }
        }
        let temp = f; f = f_new; f_new = temp;
    }

    // --- 3. THREE.JS VISUALIZATION ---
    const scene = new THREE.Scene();
    
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, -90, 90);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // --- Lights ---
    const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
    scene.add(ambientLight);

    const pLight1 = new THREE.PointLight(0x0088ff, 2, 200);
    pLight1.position.set(50, 50, 50);
    scene.add(pLight1);

    const pLight2 = new THREE.PointLight(0xffffff, 1, 200);
    pLight2.position.set(-50, -50, 50);
    scene.add(pLight2);

    // --- Mesh ---
    const geometry = new THREE.PlaneGeometry(1, 1, NX, NY);
    
    const material = new THREE.MeshPhysicalMaterial({ 
        color: 0x00aaff, 
        metalness: 0.2,
        roughness: 0.1,
        clearcoat: 1.0,
        clearcoatRoughness: 0.1,
        transmission: 0.1,
        opacity: 0.9,
        transparent: true,
        side: THREE.DoubleSide,
        flatShading: false
    });

    const torusMesh = new THREE.Mesh(geometry, material);
    torusMesh.castShadow = true;
    torusMesh.receiveShadow = true;
    scene.add(torusMesh);

    // --- MAPPING LBM TO TORUS GEOMETRY ---
    function updateTorusGeometry() {
        const positions = torusMesh.geometry.attributes.position.array;

        // Deform Torus based on TILT (Orientation)
        const currentMajor = majorRadius + (tiltX * 0.2); 
        const currentMinor = minorRadius + (tiltY * 0.1);

        for (let j = 0; j <= NY; j++) {
            for (let i = 0; i <= NX; i++) {
                const gridX = i % NX;
                const gridY = j % NY;
                const lbmIdx = gridY * NX + gridX;
                
                const d = rho[lbmIdx];

                // Add "Liquid Height" to the minor radius
                let h = 0;
                if (d > 1.05) h = (d - 1.05) * 8.0; 

                const u = (i / NX) * Math.PI * 2;
                const v = (j / NY) * Math.PI * 2;

                const r = currentMinor + h; 

                // Parametric Torus
                const x = (currentMajor + r * Math.cos(v)) * Math.cos(u);
                const y = (currentMajor + r * Math.cos(v)) * Math.sin(u);
                const z = r * Math.sin(v);

                const posIdx = (j * (NX + 1) + i) * 3;
                positions[posIdx] = x;
                positions[posIdx + 1] = y;
                positions[posIdx + 2] = z;
            }
        }
        
        torusMesh.geometry.attributes.position.needsUpdate = true;
        torusMesh.geometry.computeVertexNormals();
    }

    // --- 4. INPUT HANDLING ---
    
    // A. TILT (Orientation) -> Deforms the Geometry
    function handleOrientation(event) {
        let x = event.gamma || 0; 
        let y = event.beta || 0;  

        if (x > 45) x = 45; if (x < -45) x = -45;
        if (y > 45) y = 45; if (y < -45) y = -45;

        tiltX = x;
        tiltY = y;
    }

    // B. MOTION (Acceleration) -> Perturbs the Liquid
    function handleMotion(event) {
        // accelerationIncludingGravity gives us the raw physics impulse
        const acc = event.accelerationIncludingGravity;
        if (!acc) return;

        // X/Y Acceleration drives the fluid flow directly (Inertia)
        // We use a small multiplier to inject this into LBM velocity
        forceX += (acc.x || 0) * 0.0005;
        forceY += (acc.y || 0) * 0.0005;

        // Calculate "Jerk" or Shake magnitude to create turbulence
        // We use acceleration without gravity if available for pure shake
        const shakeAcc = event.acceleration || acc;
        const magnitude = Math.sqrt(shakeAcc.x**2 + shakeAcc.y**2 + shakeAcc.z**2);
        
        // If shaking hard, add energy
        if (magnitude > 3.0) {
            shakeEnergy += magnitude * 0.01;
            // Cap shake energy
            if (shakeEnergy > 1.0) shakeEnergy = 1.0;
        }
    }

    // --- Viscosity Control ---
    let isDragging = false;
    let startY = 0;
    let startVisc = 0;
    const colorWater = new THREE.Color(0x00aaff); 
    const colorHoney = new THREE.Color(0xffaa00);
    const labelEl = document.getElementById('viscosity-label');

    function onPointerDown(e) {
        isDragging = true;
        startY = e.touches ? e.touches[0].clientY : e.clientY;
        startVisc = viscosity;
    }

    function onPointerMove(e) {
        if (!isDragging) return;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const deltaY = startY - clientY; 
        let newVisc = startVisc + (deltaY * 0.0005);
        newVisc = Math.max(0.02, Math.min(newVisc, 0.25));
        updateViscosity(newVisc);
    }

    function onPointerUp() { isDragging = false; }

    function updateViscosity(val) {
        viscosity = val;
        omega = 1.0 / (3.0 * viscosity + 0.5);
        const t = (viscosity - 0.02) / (0.23); 

        torusMesh.material.color.lerpColors(colorWater, colorHoney, t);
        pLight1.color.lerpColors(new THREE.Color(0x0088ff), new THREE.Color(0xffcc00), t * 0.5);

        if (t < 0.2) labelEl.innerText = "WATER";
        else if (t < 0.5) labelEl.innerText = "OIL";
        else if (t < 0.8) labelEl.innerText = "SYRUP";
        else labelEl.innerText = "HONEY";
    }

    // Listeners
    window.addEventListener('mousedown', onPointerDown);
    window.addEventListener('mousemove', onPointerMove);
    window.addEventListener('mouseup', onPointerUp);
    window.addEventListener('touchstart', onPointerDown, {passive: false});
    window.addEventListener('touchmove', (e) => { e.preventDefault(); onPointerMove(e); }, {passive: false});
    window.addEventListener('touchend', onPointerUp);

    // --- APP LOOP ---
    function requestAccess() {
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            // Requesting access for both Orientation and Motion
            Promise.all([
                DeviceOrientationEvent.requestPermission(),
                DeviceMotionEvent.requestPermission()
            ]).then(responses => {
                if (responses.every(r => r === 'granted')) {
                    window.addEventListener('deviceorientation', handleOrientation);
                    window.addEventListener('devicemotion', handleMotion);
                    startSim();
                } else {
                    alert("Sensors required for full effect.");
                    startSim();
                }
            }).catch(console.error);
        } else {
            // Non-iOS or older devices
            window.addEventListener('deviceorientation', handleOrientation);
            window.addEventListener('devicemotion', handleMotion);
            startSim();
        }
    }

    function startSim() {
        document.getElementById('overlay').style.opacity = '0';
        setTimeout(() => { document.getElementById('overlay').style.display = 'none'; }, 500);
        running = true;
        initLBM();
        animate();
    }

    function animate() {
        requestAnimationFrame(animate);
        if (!running) return;

        stepLBM();
        stepLBM(); 
        
        updateTorusGeometry();
        renderer.render(scene, camera);
    }

    document.getElementById('startBtn').addEventListener('click', requestAccess);

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
