<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Liquid Torus</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; user-select: none; }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            background: rgba(0,0,0,0.6); color: white; z-index: 10;
            flex-direction: column; text-align: center; backdrop-filter: blur(5px);
        }
        h1 { margin-bottom: 5px; font-weight: 300; letter-spacing: 2px; }
        p { color: #aaa; font-size: 14px; margin-bottom: 30px; }
        button {
            padding: 18px 40px; font-size: 16px; background: white;
            border: none; border-radius: 30px; color: #000; cursor: pointer; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.3); transition: transform 0.1s;
            font-weight: 600; text-transform: uppercase; letter-spacing: 1px;
        }
        button:active { transform: scale(0.95); }
        #viscosity-label {
            position: absolute; top: 30px; width: 100%; text-align: center;
            color: rgba(255,255,255,0.8); pointer-events: none; font-size: 16px;
            font-weight: 300; letter-spacing: 4px; text-transform: uppercase;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
            transition: color 0.3s;
        }
        #hint { 
            position: absolute; bottom: 30px; width: 100%; text-align: center; 
            color: rgba(255,255,255,0.3); pointer-events: none; font-size: 12px;
            text-transform: uppercase; letter-spacing: 2px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

<div id="viscosity-label">WATER</div>
<div id="hint">Tilt to Deform & Flow â€¢ Drag to Thicken</div>

<div id="overlay">
    <div>
        <h1>LIQUID TORUS</h1>
        <p>Viscous Surface Simulation</p>
        <button id="startBtn">Start</button>
    </div>
</div>

<script>
    // --- CONFIGURATION ---
    const NX = 100; // Resolution around major axis
    const NY = 50;  // Resolution around tube
    const Q = 9; 
    
    // Torus Base Geometry
    let majorRadius = 30; 
    let minorRadius = 12;

    // Dynamics
    let viscosity = 0.02; 
    let omega = 1.0 / (3.0 * viscosity + 0.5);
    let running = false;

    // --- LBM VARIABLES ---
    const SIZE = NX * NY * Q;
    let f = new Float32Array(SIZE);
    let f_new = new Float32Array(SIZE);
    let rho = new Float32Array(NX * NY); 
    
    const w = [4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36];
    const cx = [0, 1, 0, -1, 0, 1, -1, -1, 1];
    const cy = [0, 0, 1, 0, -1, 1, 1, -1, -1];
    const opposite = [0, 3, 4, 1, 2, 7, 8, 5, 6]; 

    // Forces from Gyro
    let forceX = 0.0;
    let forceY = 0.0;
    let tiltX = 0.0; // Used for deformation
    let tiltY = 0.0;

    // --- 1. INITIALIZATION ---
    function initLBM() {
        for (let y = 0; y < NY; y++) {
            for (let x = 0; x < NX; x++) {
                const idx = y * NX + x;
                // Add some initial turbulence/blobs
                let initialRho = 1.0;
                if (Math.random() > 0.95) initialRho += 2.5; 
                rho[idx] = initialRho;
                for (let i = 0; i < Q; i++) f[idx * Q + i] = w[i] * initialRho;
            }
        }
    }

    // --- 2. PHYSICS LOOP (Periodic) ---
    function stepLBM() {
        for (let y = 0; y < NY; y++) {
            for (let x = 0; x < NX; x++) {
                const idx = y * NX + x;
                
                let sumRho = 0;
                let sumUx = 0;
                let sumUy = 0;

                for (let i = 0; i < Q; i++) {
                    const fi = f[idx * Q + i];
                    sumRho += fi;
                    sumUx += fi * cx[i];
                    sumUy += fi * cy[i];
                }

                rho[idx] = sumRho;
                
                // Add gravity/flow forces based on Tilt
                sumUx += forceX * sumRho;
                sumUy += forceY * sumRho;

                const localUx = sumUx / sumRho;
                const localUy = sumUy / sumRho;
                const u2 = localUx * localUx + localUy * localUy;

                for (let i = 0; i < Q; i++) {
                    const cidotU = cx[i] * localUx + cy[i] * localUy;
                    const feq = w[i] * sumRho * (1 + 3 * cidotU + 4.5 * cidotU * cidotU - 1.5 * u2);
                    const postCollision = f[idx * Q + i] * (1 - omega) + feq * omega;

                    // Periodic Wrap-around
                    let nextX = (x + cx[i] + NX) % NX;
                    let nextY = (y + cy[i] + NY) % NY;

                    f_new[(nextY * NX + nextX) * Q + i] = postCollision;
                }
            }
        }
        let temp = f; f = f_new; f_new = temp;
    }

    // --- 3. THREE.JS VISUALIZATION ---
    const scene = new THREE.Scene();
    
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, -90, 90);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // --- Lights ---
    const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
    scene.add(ambientLight);

    const pLight1 = new THREE.PointLight(0x0088ff, 2, 200);
    pLight1.position.set(50, 50, 50);
    scene.add(pLight1);

    const pLight2 = new THREE.PointLight(0xffffff, 1, 200);
    pLight2.position.set(-50, -50, 50);
    scene.add(pLight2);

    // --- Liquid Mesh ---
    // Note: NX and NY match the LBM grid. 
    // We add 1 to vertices count to close the loop smoothly in ThreeJS logic, 
    // but we map the UVs to wrap perfectly.
    const geometry = new THREE.PlaneGeometry(1, 1, NX, NY);
    
    const material = new THREE.MeshPhysicalMaterial({ 
        color: 0x00aaff, 
        metalness: 0.2,
        roughness: 0.1,
        clearcoat: 1.0,
        clearcoatRoughness: 0.1,
        transmission: 0.1,
        opacity: 0.9,
        transparent: true,
        side: THREE.DoubleSide,
        flatShading: false
    });

    const torusMesh = new THREE.Mesh(geometry, material);
    torusMesh.castShadow = true;
    torusMesh.receiveShadow = true;
    scene.add(torusMesh);

    // --- MAPPING LBM TO TORUS GEOMETRY ---
    function updateTorusGeometry() {
        const positions = torusMesh.geometry.attributes.position.array;
        const vertexCount = (NX + 1) * (NY + 1);

        // Deform Torus based on Tilt
        // X Tilt makes it wider/thinner
        // Y Tilt stretches it vertically
        const currentMajor = majorRadius + (tiltX * 0.2); 
        const currentMinor = minorRadius + (tiltY * 0.1);

        for (let j = 0; j <= NY; j++) {
            for (let i = 0; i <= NX; i++) {
                // Map mesh index to LBM grid index (wrapping)
                const gridX = i % NX;
                const gridY = j % NY;
                const lbmIdx = gridY * NX + gridX;
                
                const d = rho[lbmIdx];

                // Add "Liquid Height" to the minor radius
                // Thresholding to make it look like droplets/waves on surface
                let h = 0;
                if (d > 1.05) h = (d - 1.05) * 8.0; 

                // Angles
                const u = (i / NX) * Math.PI * 2;
                const v = (j / NY) * Math.PI * 2;

                const r = currentMinor + h; // Radius of tube at this point

                // Torus Parametric Formula
                const x = (currentMajor + r * Math.cos(v)) * Math.cos(u);
                const y = (currentMajor + r * Math.cos(v)) * Math.sin(u);
                const z = r * Math.sin(v);

                const posIdx = (j * (NX + 1) + i) * 3;
                positions[posIdx] = x;
                positions[posIdx + 1] = y;
                positions[posIdx + 2] = z;
            }
        }
        
        torusMesh.geometry.attributes.position.needsUpdate = true;
        torusMesh.geometry.computeVertexNormals();
    }

    // --- 4. INPUT HANDLING ---
    function handleOrientation(event) {
        let x = event.gamma || 0; 
        let y = event.beta || 0;  

        // Clamp
        if (x > 45) x = 45; if (x < -45) x = -45;
        if (y > 45) y = 45; if (y < -45) y = -45;

        // 1. Fluid Flow Forces (Gentle push)
        forceX = (x / 45) * 0.002;
        forceY = -(y / 45) * 0.002;

        // 2. Geometry Deformation (Visual Squeeze)
        tiltX = x;
        tiltY = y;
    }

    // --- Viscosity Control (Color + Thickness) ---
    let isDragging = false;
    let startY = 0;
    let startVisc = 0;
    const colorWater = new THREE.Color(0x00aaff); 
    const colorHoney = new THREE.Color(0xffaa00);
    const labelEl = document.getElementById('viscosity-label');

    function onPointerDown(e) {
        isDragging = true;
        startY = e.touches ? e.touches[0].clientY : e.clientY;
        startVisc = viscosity;
    }

    function onPointerMove(e) {
        if (!isDragging) return;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const deltaY = startY - clientY; 
        let newVisc = startVisc + (deltaY * 0.0005);
        newVisc = Math.max(0.02, Math.min(newVisc, 0.25));
        updateViscosity(newVisc);
    }

    function onPointerUp() { isDragging = false; }

    function updateViscosity(val) {
        viscosity = val;
        omega = 1.0 / (3.0 * viscosity + 0.5);
        const t = (viscosity - 0.02) / (0.23); 

        // Update Color
        torusMesh.material.color.lerpColors(colorWater, colorHoney, t);
        
        // Update Light for atmosphere
        pLight1.color.lerpColors(new THREE.Color(0x0088ff), new THREE.Color(0xffcc00), t * 0.5);

        // Labels
        if (t < 0.2) labelEl.innerText = "WATER";
        else if (t < 0.5) labelEl.innerText = "OIL";
        else if (t < 0.8) labelEl.innerText = "SYRUP";
        else labelEl.innerText = "HONEY";
    }

    // Listeners
    window.addEventListener('mousedown', onPointerDown);
    window.addEventListener('mousemove', onPointerMove);
    window.addEventListener('mouseup', onPointerUp);
    window.addEventListener('touchstart', onPointerDown, {passive: false});
    window.addEventListener('touchmove', (e) => { e.preventDefault(); onPointerMove(e); }, {passive: false});
    window.addEventListener('touchend', onPointerUp);

    // --- APP LOOP ---
    function requestAccess() {
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(response => {
                    if (response === 'granted') {
                        window.addEventListener('deviceorientation', handleOrientation);
                        startSim();
                    } else {
                        alert("Gyro required for deformation.");
                        startSim();
                    }
                })
                .catch(() => startSim());
        } else {
            window.addEventListener('deviceorientation', handleOrientation);
            startSim();
        }
    }

    function startSim() {
        document.getElementById('overlay').style.opacity = '0';
        setTimeout(() => { document.getElementById('overlay').style.display = 'none'; }, 500);
        running = true;
        initLBM();
        animate();
    }

    function animate() {
        requestAnimationFrame(animate);
        if (!running) return;

        stepLBM();
        stepLBM(); // Double step for speed
        
        updateTorusGeometry();
        renderer.render(scene, camera);
    }

    document.getElementById('startBtn').addEventListener('click', requestAccess);

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
