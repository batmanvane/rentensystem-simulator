<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sticky Balanced Stack</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a1a; font-family: 'Segoe UI', sans-serif; }

        /* UI OVERLAY */
        #hud {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column;
            justify-content: space-between; padding: 30px; box-sizing: border-box;
        }

        /* The Stability Meter */
        #meter-container {
            width: 300px; height: 8px; background: rgba(255,255,255,0.2);
            border-radius: 4px; align-self: center; position: relative;
            overflow: hidden; margin-top: 50px;
        }
        #meter-fill {
            position: absolute; top: 0; left: 50%; width: 0%; height: 100%;
            background: #00ff00; transition: background 0.2s;
        }
        
        #stats {
            text-align: center; color: #fff; text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }
        h2 { margin: 0; font-size: 40px; color: #ffcc00; }
        p { margin: 5px 0 0 0; color: #aaa; font-size: 14px; }

        /* Timer Ring */
        #timer-ring {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 200px; height: 200px; border-radius: 50%;
            border: 4px solid rgba(255, 255, 255, 0.1);
            pointer-events: none;
        }
        /* The visual "fill" for the timer */
        #timer-progress {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(-90deg);
            width: 200px; height: 200px;
        }
        circle {
            fill: none; stroke: #ffcc00; stroke-width: 4; stroke-dasharray: 628; stroke-dashoffset: 628;
            transition: stroke-dashoffset 0.1s linear;
        }

        /* Start Screen */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 20;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto;
        }
        button {
            background: #ffcc00; color: black; border: none; padding: 20px 60px;
            font-size: 20px; font-weight: bold; border-radius: 50px; cursor: pointer;
            box-shadow: 0 0 30px rgba(255, 200, 0, 0.4);
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

<div id="hud">
    <div id="meter-container">
        <div id="meter-fill"></div>
    </div>
    
    <div id="timer-ring">
        <svg id="timer-progress">
            <circle cx="100" cy="100" r="98"></circle>
        </svg>
    </div>

    <div id="stats">
        <h2 id="score">0</h2>
        <p>PANCAKES STACKED</p>
    </div>
</div>

<div id="overlay">
    <h1 style="color:white; margin-bottom:10px;">AUTO-STACKER</h1>
    <p style="color:#aaa; margin-bottom:40px;">Keep the tower balanced. Don't let it fall.</p>
    <button id="startBtn">START BALANCING</button>
</div>

<script>
    // --- PHYSICS CONFIG ---
    const ADD_INTERVAL = 300; // Frames between new pancakes (~5 seconds)
    const VISCOSITY = 0.12;   // Very high = Sticky/Gooey
    const GRAVITY_FACTOR = 0.003; // How fast the tower falls when tilted
    const CONTROL_POWER = 0.005;  // How much your phone corrects the tilt

    // --- LBM (Fluid) VARS ---
    const NX=64, NY=64, Q=9;
    const SIZE = NX*NY*Q;
    let f=new Float32Array(SIZE), f_new=new Float32Array(SIZE);
    let rho=new Float32Array(NX*NY), ux=new Float32Array(NX*NY), uy=new Float32Array(NX*NY);
    const w=[4/9,1/9,1/9,1/9,1/9,1/36,1/36,1/36,1/36], cx=[0,1,0,-1,0,1,-1,-1,1], cy=[0,0,1,0,-1,1,1,-1,-1], opp=[0,3,4,1,2,7,8,5,6];

    // --- GAME STATE ---
    let stack = []; // Array of { mesh, xOffset, yOffset, mass }
    let frameCount = 0;
    let isRunning = false;
    let isGameOver = false;
    
    // Inverted Pendulum State
    let towerAngleX = 0; // Current tilt of the tower (radians)
    let towerAngleY = 0; 
    let towerVelocityX = 0; // How fast it's falling
    let towerVelocityY = 0;
    
    // User Input
    let inputTiltX = 0, inputTiltY = 0;
    
    // --- THREE.JS ---
    let scene, camera, renderer;
    let plateGroup; // The entire world that tilts
    let fluidMesh;  // The active wet pancake
    let stackGroup; // The rigid frozen pancakes

    // ==========================================
    // 1. LBM SIMULATION (The "Wet" Layer)
    // ==========================================
    function initLBM() {
        const OMEGA = 1.0 / (3.0 * VISCOSITY + 0.5);
        
        // Randomize the pour location slightly (creates the imbalance!)
        const offsetX = (Math.random() - 0.5) * 8;
        const offsetY = (Math.random() - 0.5) * 8;
        
        for(let y=0; y<NY; y++) {
            for(let x=0; x<NX; x++) {
                const i = y*NX + x;
                const dx = (x - NX/2) - offsetX;
                const dy = (y - NY/2) - offsetY;
                // Irregular blob shape
                const noise = Math.sin(x*0.3)*Math.cos(y*0.3)*2;
                const r = 10 + (Math.random()*2);
                
                let d = 1.0;
                if((dx*dx + dy*dy) < (r+noise)**2) d = 2.0; // Thick batter
                
                rho[i] = d;
                ux[i]=0; uy[i]=0;
                for(let k=0; k<Q; k++) f[i*Q+k] = w[k]*d;
            }
        }
        return OMEGA;
    }

    function stepLBM(omega) {
        // The active fluid is affected by the TOWER'S tilt
        // If tower leans left, fluid slides left
        const gX = towerAngleY * 0.1; 
        const gY = -towerAngleX * 0.1;

        for(let y=0; y<NY; y++) {
            for(let x=0; x<NX; x++) {
                const i = y*NX + x;
                let sRho=0, sUx=0, sUy=0;
                for(let k=0; k<Q; k++) {
                    let val = f[i*Q+k];
                    sRho+=val; sUx+=val*cx[k]; sUy+=val*cy[k];
                }
                rho[i]=sRho;
                
                // Add forces: Gravity from Tilt + Surface Tension
                sUx += (gX - (x-NX/2)*0.002) * sRho;
                sUy += (gY - (y-NY/2)*0.002) * sRho;

                let u = sUx/sRho, v = sUy/sRho;
                const u2 = u*u + v*v;
                
                for(let k=0; k<Q; k++) {
                    const cu = cx[k]*u + cy[k]*v;
                    const feq = w[k]*sRho*(1+3*cu+4.5*cu*cu-1.5*u2);
                    const nVal = f[i*Q+k]*(1-omega) + feq*omega;
                    const nx=x+cx[k], ny=y+cy[k];
                    if(nx>=0&&nx<NX&&ny>=0&&ny<NY) f_new[(ny*NX+nx)*Q+k] = nVal;
                    else f_new[i*Q+opp[k]] = nVal;
                }
            }
        }
        let t=f; f=f_new; f_new=t;
    }

    // ==========================================
    // 2. PHYSICS ENGINE (Inverted Pendulum)
    // ==========================================
    function updateTowerPhysics() {
        // 1. Calculate Physics Properties of the Pile
        let totalMass = 0;
        let weightedHeight = 0; // To determine moment of inertia approx
        
        // Add active fluid mass
        // (Simplified: Assume fluid adds weight at top)
        const currentHeight = stack.length * 1.2;
        const fluidMass = 20; 
        
        totalMass += fluidMass;
        weightedHeight += fluidMass * (currentHeight + 1);

        // Add stack mass
        stack.forEach((layer, index) => {
            totalMass += layer.mass;
            weightedHeight += layer.mass * (index * 1.2);
        });

        // 2. Calculate Stability Forces
        // The Taller the stack (weightedHeight), the faster it falls
        const instabilityFactor = 1.0 + (weightedHeight / 500.0); 
        
        // GRAVITY FORCE: Pushes tower further down if already tilted
        const gravityForceX = Math.sin(towerAngleX) * GRAVITY_FACTOR * instabilityFactor;
        const gravityForceY = Math.sin(towerAngleY) * GRAVITY_FACTOR * instabilityFactor;

        // CONTROL FORCE: User trying to push it back up
        // We subtract input because we want to COUNTER the tilt
        const correctionX = -inputTiltX * CONTROL_POWER;
        const correctionY = -inputTiltY * CONTROL_POWER;

        // 3. Integrate Euler
        towerVelocityX += (gravityForceX + correctionX);
        towerVelocityY += (gravityForceY + correctionY);

        // Dampening (Air resistance / Friction)
        towerVelocityX *= 0.98;
        towerVelocityY *= 0.98;

        towerAngleX += towerVelocityX;
        towerAngleY += towerVelocityY;

        // 4. Fail State
        // If tilt exceeds ~25 degrees (0.45 rads), it topples
        const maxTilt = 0.45;
        const currentTilt = Math.sqrt(towerAngleX**2 + towerAngleY**2);
        
        // Update UI
        updateHUD(currentTilt, maxTilt);

        if (currentTilt > maxTilt) {
            gameOver();
        }
    }

    // ==========================================
    // 3. VISUALS & LOGIC
    // ==========================================
    function initThree() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
        // Position camera to see the stack from an angle (Top-Side view)
        camera.position.set(0, 30, 40); 
        camera.lookAt(0, 5, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lights
        scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        const light = new THREE.PointLight(0xffaa00, 1, 100);
        light.position.set(20, 30, 20);
        light.castShadow = true;
        scene.add(light);

        // Groups
        // plateGroup rotates based on physics (The Tower)
        plateGroup = new THREE.Group(); 
        scene.add(plateGroup);

        stackGroup = new THREE.Group();
        plateGroup.add(stackGroup);

        // The Plate
        const plateGeo = new THREE.CylinderGeometry(10, 10, 1, 32);
        const plateMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
        const plate = new THREE.Mesh(plateGeo, plateMat);
        plate.receiveShadow = true;
        plateGroup.add(plate);

        // The "Wet" Mesh
        const geo = new THREE.PlaneGeometry(15, 15, NX-1, NY-1);
        const mat = new THREE.MeshStandardMaterial({ 
            color: 0xffcc00, roughness: 0.3, metalness: 0.1 
        });
        fluidMesh = new THREE.Mesh(geo, mat);
        fluidMesh.rotation.x = -Math.PI/2;
        // It sits on top of the current stack height
        fluidMesh.position.y = 1.0; 
        plateGroup.add(fluidMesh);
    }

    function updateVisuals() {
        // 1. Update Wet Mesh from LBM
        const pos = fluidMesh.geometry.attributes.position.array;
        for(let i=0; i<NX*NY; i++) {
            let d = rho[i];
            let h = 0;
            if(d > 1.2) h = (d-1.2)*4.0;
            pos[i*3+2] = h;
        }
        fluidMesh.geometry.attributes.position.needsUpdate = true;
        fluidMesh.geometry.computeVertexNormals();

        // 2. Apply Physics Rotation to the World (The Balancing Act)
        // We rotate the PLATE, not the camera, to simulate the object falling
        plateGroup.rotation.x = towerAngleX;
        plateGroup.rotation.z = towerAngleY; // Z axis maps to Y tilt in this orientation

        // 3. Keep Fluid Mesh on top of stack
        fluidMesh.position.y = 1.0 + (stack.length * 1.2);
    }

    function freezeLayer() {
        if(isGameOver) return;

        // 1. Extract geometry from LBM
        const frozenGeo = fluidMesh.geometry.clone();
        const frozenMat = new THREE.MeshStandardMaterial({ 
            color: 0xeeb022, roughness: 0.8 
        });
        const mesh = new THREE.Mesh(frozenGeo, frozenMat);
        
        // 2. Add to rigid stack
        mesh.rotation.x = -Math.PI/2;
        mesh.position.y = 1.0 + (stack.length * 1.2);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        
        stackGroup.add(mesh);
        stack.push({ mass: 10, mesh: mesh });
        
        // 3. Update Score
        document.getElementById('score').innerText = stack.length;

        // 4. Reset Fluid
        initLBM();
    }

    function updateHUD(tilt, max) {
        // Stability Meter
        const pct = (tilt / max) * 100;
        const bar = document.getElementById('meter-fill');
        
        // Visually show Left/Right imbalance
        // This is a simplification for the UI bar
        bar.style.width = Math.min(pct, 100) + "%";
        bar.style.left = (50 - Math.min(pct, 100)/2) + "%"; // Centered expansion

        if(pct > 80) bar.style.background = "red";
        else bar.style.background = "#00ff00";

        // Timer Ring
        const progress = (frameCount % ADD_INTERVAL) / ADD_INTERVAL;
        const offset = 628 - (628 * progress);
        document.querySelector('circle').style.strokeDashoffset = offset;
    }

    function gameOver() {
        isGameOver = true;
        document.querySelector('h1').innerText = "TOWER FELL";
        document.getElementById('overlay').style.display = 'flex';
        document.getElementById('startBtn').innerText = "TRY AGAIN";
    }

    // --- MAIN LOOP ---
    let currentOmega = 1.0;

    function animate() {
        requestAnimationFrame(animate);
        if(!isRunning || isGameOver) return;

        // 1. Auto-Stack Timer
        frameCount++;
        if(frameCount % ADD_INTERVAL === 0) {
            freezeLayer();
            currentOmega = initLBM();
        }

        // 2. Physics Steps
        stepLBM(currentOmega);
        updateTowerPhysics();

        // 3. Render
        updateVisuals();
        renderer.render(scene, camera);
    }

    // --- INPUTS ---
    function handleOrient(e) {
        // Map gamma/beta to -1..1 range
        let x = e.gamma || 0; // Left/Right
        let y = e.beta || 0;  // Front/Back
        
        // Clamp and Normalize
        inputTiltX = Math.max(-30, Math.min(30, y)) / 30; // Swap X/Y for intuitive landscape feel?
        inputTiltY = Math.max(-30, Math.min(30, x)) / 30;
    }

    function handleMouse(e) {
        // Desktop debugging
        const x = (e.clientX / window.innerWidth)*2 - 1;
        const y = (e.clientY / window.innerHeight)*2 - 1;
        inputTiltY = x; // Mouse X controls Left/Right tilt
        inputTiltX = y; // Mouse Y controls Front/Back tilt
    }

    document.getElementById('startBtn').addEventListener('click', () => {
        if(isGameOver) location.reload();
        
        if(typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(r => { if(r==='granted') window.addEventListener('deviceorientation', handleOrient); })
                .catch(console.error);
        } else {
            window.addEventListener('deviceorientation', handleOrient);
        }
        window.addEventListener('mousemove', handleMouse);

        document.getElementById('overlay').style.display = 'none';
        isRunning = true;
        initThree();
        currentOmega = initLBM();
        animate();
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>