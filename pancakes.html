<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>LBM Pancake Tower</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: 'Courier New', monospace; }
        
        /* HUD */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column;
            justify-content: space-between; padding: 20px; box-sizing: border-box;
        }

        .hud-text {
            color: #f0e68c; text-shadow: 2px 2px 0 #000; font-weight: bold; font-size: 20px;
        }

        /* Stability Bar */
        #stability-container {
            position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%);
            width: 200px; height: 10px; background: rgba(255,255,255,0.2); border-radius: 5px;
        }
        #center-marker {
            position: absolute; top: -5px; left: 50%; width: 2px; height: 20px; background: white;
        }
        #com-dot {
            position: absolute; top: -4px; left: 50%; width: 18px; height: 18px;
            background: #00ff00; border-radius: 50%; transform: translateX(-50%);
            box-shadow: 0 0 5px #00ff00; transition: left 0.1s;
        }

        /* Overlay */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(50, 30, 10, 0.9); z-index: 20;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto;
        }
        h1 { color: #ffcc00; font-size: 40px; margin-bottom: 10px; text-transform: uppercase; }
        button {
            background: #ffcc00; color: #442200; border: none; padding: 15px 40px;
            font-size: 20px; font-weight: bold; cursor: pointer; border-radius: 8px;
            box-shadow: 0 5px 0 #aa8800; margin-top: 20px;
        }
        button:active { transform: translateY(4px); box-shadow: 0 1px 0 #aa8800; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>

<div id="ui-layer">
    <div class="hud-text" id="score-display">STACK HEIGHT: 0cm</div>
    <div class="hud-text" id="status-display" style="text-align: right; font-size: 14px;">SENSITIVITY: 1.0x</div>
    
    <div id="stability-container">
        <div id="center-marker"></div>
        <div id="com-dot"></div>
    </div>
</div>

<div id="overlay">
    <h1>PANCAKE PILE</h1>
    <p style="color:#ddd; text-align:center;">Tilt to shape the batter.<br>Tap to Cook.<br>Watch out: Taller stacks are wobbly!</p>
    <button id="startBtn">POUR BATTER</button>
</div>

<script>
    // --- CONFIGURATION ---
    const NX = 64; 
    const NY = 64;
    const Q = 9;
    // We will vary viscosity per turn for "batter consistency"
    let currentViscosity = 0.04; 
    let currentThickness = 1.0; // The "dz"
    
    // LBM Arrays
    const SIZE = NX * NY * Q;
    let f = new Float32Array(SIZE);
    let f_new = new Float32Array(SIZE);
    let rho = new Float32Array(NX * NY);
    let ux = new Float32Array(NX * NY);
    let uy = new Float32Array(NX * NY);

    // D2Q9 Constants
    const w = [4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36];
    const cx = [0, 1, 0, -1, 0, 1, -1, -1, 1];
    const cy = [0, 0, 1, 0, -1, 1, 1, -1, -1];
    const opposite = [0, 3, 4, 1, 2, 7, 8, 5, 6];

    // Physics Inputs
    let tiltX = 0, tiltY = 0; 
    let targetTiltX = 0, targetTiltY = 0;

    // Game State
    let stack = []; // { mass, x, y, z_height, mesh }
    let isRunning = false;
    let isGameOver = false;
    let currentHeight = 0;

    // Three.js Global
    let scene, camera, renderer, batterMesh, stackGroup;

    // ==========================================
    // 1. LBM SIMULATION (Fluid Batter)
    // ==========================================

    function initLBM(randomize = false) {
        // Reset Fields
        ux.fill(0); uy.fill(0); rho.fill(1.0);
        
        if(randomize) {
            // Randomize "Batter Properties"
            // 1. Thickness (0.5 to 2.0)
            currentThickness = 0.5 + Math.random() * 1.5;
            // 2. Viscosity (Runny to Thick)
            currentViscosity = 0.02 + Math.random() * 0.08;
        }

        const omega = 1.0 / (3.0 * currentViscosity + 0.5);

        // Initialize a Blob with NOISE for irregular shape
        const seedX = (Math.random() - 0.5) * 10;
        const seedY = (Math.random() - 0.5) * 10;

        for(let y=0; y<NY; y++) {
            for(let x=0; x<NX; x++) {
                const idx = y*NX + x;
                const dx = (x - NX/2) - seedX;
                const dy = (y - NY/2) - seedY;
                
                // Base Circle
                let dist = Math.sqrt(dx*dx + dy*dy);
                
                // Add Perlin-ish noise (simplified)
                let noise = Math.sin(x * 0.2) * Math.cos(y * 0.2) * 3.0;
                dist += noise;

                // Density Drop
                let d = 1.0;
                if (dist < 12) d = 2.0; // The batter blob
                rho[idx] = d;

                for(let i=0; i<Q; i++) f[idx*Q + i] = w[i] * d;
            }
        }
        return omega;
    }

    function stepLBM(omega) {
        // Sensitivity Scaling: Taller stack = More sensitive tilt
        // h_factor starts at 1.0 and increases by 0.2 per layer
        const sensitivity = 1.0 + (stack.length * 0.25);
        
        // Smooth input
        tiltX += (targetTiltX - tiltX) * 0.1;
        tiltY += (targetTiltY - tiltY) * 0.1;

        // Apply scaled force
        const forceX = tiltX * 0.001 * sensitivity;
        const forceY = tiltY * 0.001 * sensitivity;

        document.getElementById('status-display').innerText = `SENSITIVITY: ${sensitivity.toFixed(1)}x`;

        for(let y=0; y<NY; y++) {
            for(let x=0; x<NX; x++) {
                const idx = y*NX + x;
                
                let sumRho=0, sumUx=0, sumUy=0;
                for(let i=0; i<Q; i++) {
                    let val = f[idx*Q+i];
                    sumRho+=val; sumUx+=val*cx[i]; sumUy+=val*cy[i];
                }
                
                rho[idx] = sumRho;
                
                // Apply Forces (Gravity + Centering Surface Tension)
                // Surface tension holds the pancake together
                const centerFx = -(x - NX/2) * 0.0001; 
                const centerFy = -(y - NY/2) * 0.0001;

                sumUx += (forceX + centerFx) * sumRho;
                sumUy += (forceY + centerFy) * sumRho;

                const ux_val = sumUx/sumRho;
                const uy_val = sumUy/sumRho;
                
                ux[idx] = ux_val; uy[idx] = uy_val;
                const u2 = ux_val*ux_val + uy_val*uy_val;

                for(let i=0; i<Q; i++) {
                    const cu = cx[i]*ux_val + cy[i]*uy_val;
                    const feq = w[i]*sumRho*(1 + 3*cu + 4.5*cu*cu - 1.5*u2);
                    const nVal = f[idx*Q+i]*(1-omega) + feq*omega;
                    
                    const nx = x+cx[i];
                    const ny = y+cy[i];
                    
                    if(nx>=0 && nx<NX && ny>=0 && ny<NY) {
                        f_new[(ny*NX+nx)*Q+i] = nVal;
                    } else {
                        f_new[idx*Q+opposite[i]] = nVal;
                    }
                }
            }
        }
        let t=f; f=f_new; f_new=t;
    }

    // ==========================================
    // 2. THREE.JS VISUALS
    // ==========================================

    function initThree() {
        scene = new THREE.Scene();
        
        // Top-Down Camera, starting zoomed in
        camera = new THREE.PerspectiveCamera(40, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 50); 
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const amb = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(amb);
        
        const sun = new THREE.DirectionalLight(0xffffff, 0.8);
        sun.position.set(20, 20, 50);
        sun.castShadow = true;
        sun.shadow.mapSize.width = 1024;
        sun.shadow.mapSize.height = 1024;
        scene.add(sun);

        // The Plate
        const plateGeo = new THREE.CylinderGeometry(12, 12, 1, 64);
        const plateMat = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.2 });
        const plate = new THREE.Mesh(plateGeo, plateMat);
        plate.rotation.x = Math.PI / 2;
        plate.receiveShadow = true;
        scene.add(plate);

        stackGroup = new THREE.Group();
        scene.add(stackGroup);

        // The "Active Batter" Mesh
        const batterGeo = new THREE.PlaneGeometry(20, 20, NX-1, NY-1);
        const batterMat = new THREE.MeshStandardMaterial({ 
            color: 0xeebb44, // Raw batter color
            roughness: 0.4,
            metalness: 0.0
        });
        batterMesh = new THREE.Mesh(batterGeo, batterMat);
        scene.add(batterMesh);
    }

    function updateBatterVisuals() {
        // Visualize the LBM grid
        const pos = batterMesh.geometry.attributes.position.array;
        const colors = [];
        
        for(let i=0; i<NX*NY; i++) {
            let d = rho[i];
            // Map density to height (Z)
            // Threshold to cut off "air"
            let h = 0;
            if (d > 1.1) {
                h = (d - 1.1) * 8.0 * currentThickness; 
            }
            
            // We move the vertices in Z (towards camera)
            pos[i*3 + 2] = h + currentHeight; 
        }
        batterMesh.geometry.attributes.position.needsUpdate = true;
        batterMesh.geometry.computeVertexNormals();
    }

    // ==========================================
    // 3. GAME LOGIC & STACKING
    // ==========================================

    function calculateFluidCentroid() {
        let totalM = 0, sumX = 0, sumY = 0;
        
        for(let y=0; y<NY; y++) {
            for(let x=0; x<NX; x++) {
                const d = rho[y*NX + x];
                if (d > 1.2) {
                    // Mass is Density * Thickness (roughly)
                    const mass = d * currentThickness;
                    totalM += mass;
                    // Convert grid to world coords (Plane is 20x20)
                    const wx = (x / NX - 0.5) * 20;
                    const wy = (y / NY - 0.5) * 20;
                    
                    sumX += mass * wx;
                    sumY += mass * wy;
                }
            }
        }
        
        if(totalM === 0) return {x:0, y:0, m:0};
        return { x: sumX/totalM, y: sumY/totalM, m: totalM };
    }

    function cookPancake() {
        if(isGameOver) return;

        const data = calculateFluidCentroid();
        if(data.m === 0) return; // Empty pour

        // 1. Create Static Mesh (The Cooked Pancake)
        // We clone the current active mesh geometry to freeze the shape
        const cookedGeo = batterMesh.geometry.clone();
        const cookedMat = new THREE.MeshStandardMaterial({ 
            color: getPancakeColor(), 
            roughness: 0.8 
        });
        const mesh = new THREE.Mesh(cookedGeo, cookedMat);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        stackGroup.add(mesh);

        // 2. Add to Physics Stack
        stack.push({
            mass: data.m,
            x: data.x,
            y: data.y,
            z: currentHeight
        });

        // 3. Update Height & Camera
        currentHeight += currentThickness; 
        document.getElementById('score-display').innerText = `STACK HEIGHT: ${stack.length}`;
        
        // Zoom out logic: Move camera away as stack grows
        new TWEEN.Tween(camera.position)
            .to({ z: 50 + (currentHeight * 3.0) }, 1000)
            .easing(TWEEN.Easing.Cubic.Out)
            .start();

        // 4. Check Stability
        const globalCoM = calculateGlobalCoM();
        const r = Math.sqrt(globalCoM.x**2 + globalCoM.y**2);
        
        // Plate radius is roughly 6.0 world units
        // If CoM deviates too far, topple.
        if(r > 5.0) {
            gameOver(globalCoM);
        } else {
            // Reset for next round
            currentOmega = initLBM(true); // Randomize next
        }
    }

    function calculateGlobalCoM() {
        let tm = 0, tx = 0, ty = 0;
        stack.forEach(p => {
            tm += p.mass;
            tx += p.mass * p.x;
            ty += p.mass * p.y;
        });
        if(tm === 0) return {x:0, y:0};
        return { x: tx/tm, y: ty/tm };
    }

    function getPancakeColor() {
        // Randomize shades of golden brown
        const hue = 30 + Math.random() * 15; // 30-45 (Orange-Yellow)
        const sat = 70 + Math.random() * 20;
        const light = 40 + Math.random() * 20;
        return `hsl(${hue}, ${sat}%, ${light}%)`;
    }

    function updateStabilityUI() {
        // We want to show the Global CoM relative to the active fluid
        // Actually, stability is determined by the solid stack, 
        // but the player is using the active fluid to counterbalance.
        
        // Combine Stack + Active Fluid for the "Projected" CoM
        const stackCoM = calculateGlobalCoM(); // Current stable center
        const fluid = calculateFluidCentroid(); // Where the new weight is
        
        let totalM = 0, totalX = 0, totalY = 0;
        
        // Sum stack
        stack.forEach(p => {
            totalM += p.mass;
            totalX += p.mass * p.x;
            totalY += p.mass * p.y;
        });
        
        // Add current fluid
        totalM += fluid.m;
        totalX += fluid.m * fluid.x;
        totalY += fluid.m * fluid.y;
        
        const finalX = totalM ? totalX/totalM : 0;
        
        // UI Mapping
        // Limit is +/- 5.0 world units. Map to +/- 100px in UI
        const px = (finalX / 5.0) * 100;
        
        const dot = document.getElementById('com-dot');
        dot.style.left = `calc(50% + ${px}px)`;
        
        if(Math.abs(px) > 90) dot.style.background = "red";
        else dot.style.background = "#00ff00";
    }

    function gameOver(dir) {
        isGameOver = true;
        document.getElementById('overlay').style.display = 'flex';
        document.querySelector('h1').innerText = "TOPPLED!";
        document.querySelector('p').innerText = `Final Height: ${stack.length}`;
        document.getElementById('startBtn').innerText = "Retry";

        // Topple Animation
        new TWEEN.Tween(stackGroup.rotation)
            .to({ x: dir.y * 0.2, y: -dir.x * 0.2 }, 1000)
            .easing(TWEEN.Easing.Bounce.Out)
            .start();
    }

    // ==========================================
    // 4. LOOPS & INPUTS
    // ==========================================

    let currentOmega;

    function animate(time) {
        requestAnimationFrame(animate);
        TWEEN.update(time);

        if(isRunning && !isGameOver) {
            stepLBM(currentOmega);
            stepLBM(currentOmega); // Double step
            updateBatterVisuals();
            updateStabilityUI();
        }
        
        renderer.render(scene, camera);
    }

    function handleOrient(e) {
        if(isGameOver) return;
        let x = e.gamma || 0; 
        let y = e.beta || 0; 
        // Limit max tilt
        if(x>30) x=30; if(x<-30) x=-30;
        if(y>30) y=30; if(y<-30) y=-30;
        targetTiltX = x;
        targetTiltY = -y; // Invert Y
    }

    function handleMouse(e) {
        if(isGameOver) return;
        const x = (e.clientX / window.innerWidth)*2-1;
        const y = (e.clientY / window.innerHeight)*2-1;
        targetTiltX = x * 30;
        targetTiltY = y * 30;
    }

    function handleTap() {
        if(isRunning && !isGameOver) cookPancake();
    }

    document.getElementById('startBtn').addEventListener('click', () => {
        if(isGameOver) location.reload();
        
        if(typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(r=>{if(r==='granted')window.addEventListener('deviceorientation', handleOrient)});
        } else {
            window.addEventListener('deviceorientation', handleOrient);
        }
        window.addEventListener('mousemove', handleMouse);
        window.addEventListener('mousedown', handleTap);
        window.addEventListener('touchstart', handleTap);

        document.getElementById('overlay').style.display = 'none';
        isRunning = true;
        initThree();
        currentOmega = initLBM(true);
        animate();
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>