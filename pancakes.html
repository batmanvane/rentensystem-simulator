<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Rocket Stack Challenge</title>
    <style>
        body { margin: 0; overflow: hidden; background: #0b0b15; font-family: 'Courier New', monospace; }
        
        /* HUD */
        #hud {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
        }

        /* The Crosshair (Your view center) */
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 20px; height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        
        /* The "Safe Zone" Ring */
        #safe-ring {
            position: absolute; top: 50%; left: 50%;
            width: 120px; height: 120px; /* If the green dot leaves this, you die */
            border: 2px dashed rgba(0, 255, 0, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: border-color 0.2s;
        }

        /* The CoM Indicator (The Bubble Level) */
        #bubble-level {
            position: absolute; top: 50%; left: 50%;
            width: 16px; height: 16px;
            background: #00ff00; border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 8px #00ff00;
            transition: background 0.2s;
        }

        #altitude-meter {
            position: absolute; right: 20px; top: 50%; transform: translateY(-50%);
            height: 300px; width: 6px; background: rgba(255,255,255,0.1);
            border-radius: 3px;
        }
        #altitude-fill {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 0%;
            background: linear-gradient(to top, #ffaa00, #ff0055);
            transition: height 0.5s;
        }
        #score-text {
            position: absolute; right: 35px; top: 50%; transform: translateY(-50%);
            color: white; font-size: 24px; font-weight: bold;
        }

        /* Timer Circle */
        #timer-svg {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            width: 60px; height: 60px;
        }
        circle {
            fill: none; stroke: #ffaa00; stroke-width: 5; 
            stroke-dasharray: 157; stroke-dashoffset: 0;
            transition: stroke-dashoffset 0.1s linear;
        }

        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: flex; flex-direction: column;
            align-items: center; justify-content: center; pointer-events: auto; z-index: 20;
        }
        button {
            background: #00ffaa; color: #003322; border: none; padding: 18px 50px;
            font-size: 18px; font-weight: 900; letter-spacing: 2px; cursor: pointer;
            text-transform: uppercase; border-radius: 4px;
            box-shadow: 0 0 20px rgba(0, 255, 170, 0.4);
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>

<div id="hud">
    <div id="safe-ring"></div>
    <div id="crosshair"></div> <div id="bubble-level"></div> <div id="timer-svg">
        <svg width="60" height="60" viewBox="0 0 60 60">
            <circle cx="30" cy="30" r="25" transform="rotate(-90 30 30)"></circle>
        </svg>
    </div>

    <div id="altitude-meter">
        <div id="altitude-fill"></div>
    </div>
    <div id="score-text">0m</div>
</div>

<div id="overlay">
    <h1 style="color:white; letter-spacing: 4px;">ROCKET STACK</h1>
    <p style="color:#888; margin-bottom: 30px;">Hold Flat. Keep the Bubble Centered.<br>Automatic Pouring.</p>
    <button id="startBtn">IGNITION</button>
</div>

<script>
    // --- PHYSICS CONFIG ---
    const ADD_INTERVAL = 240; // 4 seconds per layer at 60fps
    const VISCOSITY = 0.08;   // Sticky batter
    
    // Non-Linear Difficulty Variables
    // Instability = TILT * (BASE + HEIGHT^2 * SCALE)
    const BASE_INSTABILITY = 0.0;  // Start perfectly stable
    const HEIGHT_SCALING = 0.0002; // Very slow ramp up
    const CONTROL_POWER = 0.008;   // How strong your phone tilt is

    // --- LBM VARS ---
    const NX=64, NY=64, Q=9;
    let f = new Float32Array(NX*NY*Q), f_new = new Float32Array(NX*NY*Q);
    let rho = new Float32Array(NX*NY);
    const w=[4/9,1/9,1/9,1/9,1/9,1/36,1/36,1/36,1/36], cx=[0,1,0,-1,0,1,-1,-1,1], cy=[0,0,1,0,-1,1,1,-1,-1], opp=[0,3,4,1,2,7,8,5,6];

    // --- GAME STATE ---
    let stack = []; 
    let frameCount = 0;
    let isRunning = false;
    let isGameOver = false;
    
    // Pendulum Physics State
    // We represent tilt as X/Y offset of the "Ground" relative to the "Top"
    let tiltX = 0; 
    let tiltY = 0; 
    let velX = 0;
    let velY = 0;
    
    // User Input
    let inputX = 0, inputY = 0;

    // --- THREE.JS ---
    let scene, camera, renderer;
    let groundGroup, stackGroup, activeMesh;

    // ==========================================
    // 1. LBM (Active Layer)
    // ==========================================
    function initLBM() {
        const omega = 1.0 / (3.0 * VISCOSITY + 0.5);
        // Start in center
        for(let i=0; i<NX*NY; i++) {
            let x=i%NX, y=Math.floor(i/NX);
            let dx=x-NX/2, dy=y-NY/2;
            let d = 1.0;
            // Random blob shape
            if(dx*dx + dy*dy < 80 + Math.random()*20) d = 2.0;
            rho[i]=d;
            for(let k=0; k<Q; k++) f[i*Q+k]=w[k]*d;
        }
        return omega;
    }

    function stepLBM(omega) {
        // Fluid slides based on TILT + INPUT
        // If the tower leans right (tiltX > 0), fluid slides right relative to the plate
        const forceX = tiltX * 0.05 + inputX * 0.02; 
        const forceY = tiltY * 0.05 + inputY * 0.02;

        for(let y=0; y<NY; y++) {
            for(let x=0; x<NX; x++) {
                let i=y*NX+x;
                let sRho=0, sUx=0, sUy=0;
                for(let k=0; k<Q; k++) {
                    let v=f[i*Q+k]; sRho+=v; sUx+=v*cx[k]; sUy+=v*cy[k];
                }
                rho[i]=sRho;
                
                // Add Forces (Slide + Surface Tension)
                sUx += (forceX - (x-NX/2)*0.001)*sRho;
                sUy += (forceY - (y-NY/2)*0.001)*sRho;
                
                let u=sUx/sRho, v=sUy/sRho;
                let u2=u*u+v*v;
                for(let k=0; k<Q; k++) {
                    let cu=cx[k]*u+cy[k]*v;
                    let feq=w[k]*sRho*(1+3*cu+4.5*cu*cu-1.5*u2);
                    let nVal=f[i*Q+k]*(1-omega)+feq*omega;
                    let nx=x+cx[k], ny=y+cy[k];
                    if(nx>=0&&nx<NX&&ny>=0&&ny<NY) f_new[(ny*NX+nx)*Q+k]=nVal;
                    else f_new[i*Q+opp[k]]=nVal;
                }
            }
        }
        let t=f; f=f_new; f_new=t;
    }

    // ==========================================
    // 2. BALANCE PHYSICS (The Rocket Logic)
    // ==========================================
    function updatePhysics() {
        const height = stack.length;
        
        // 1. Calculate "Top Heaviness"
        // Quadratic scaling: Height^2. 
        // At h=0, gravityForce is ~0. At h=50, it's strong.
        const gravityFactor = BASE_INSTABILITY + (height * height * HEIGHT_SCALING);
        
        // 2. Forces
        // Gravity pulls the tower further in the direction it's already leaning
        const gForceX = tiltX * gravityFactor;
        const gForceY = tiltY * gravityFactor;
        
        // Control pushes back (Counter-Balance)
        // We subtract input because we tilt Left to fix a Right lean
        const cForceX = -inputX * CONTROL_POWER;
        const cForceY = -inputY * CONTROL_POWER;

        // 3. Integrate
        velX += gForceX + cForceX;
        velY += gForceY + cForceY;
        
        // Friction/Air Resistance
        velX *= 0.95;
        velY *= 0.95;
        
        tiltX += velX;
        tiltY += velY;

        // 4. UI Updates & Bounds
        // Map tilt to pixels for the Bubble Level
        // 1.0 tilt = Edge of screen roughly
        const bubbleX = tiltX * 150; 
        const bubbleY = -tiltY * 150; // Invert Y for screen coords
        
        const bubble = document.getElementById('bubble-level');
        const safe = document.getElementById('safe-ring');
        
        bubble.style.transform = `translate(calc(-50% + ${bubbleX}px), calc(-50% + ${bubbleY}px))`;
        
        const dist = Math.sqrt(tiltX*tiltX + tiltY*tiltY);
        
        // Safety Threshold (The Ring)
        const limit = 0.8; 
        
        if(dist > limit * 0.7) {
            bubble.style.background = "red";
            safe.style.borderColor = "red";
        } else {
            bubble.style.background = "#00ff00";
            safe.style.borderColor = "rgba(0,255,0,0.3)";
        }

        if(dist > limit) gameOver();
    }

    // ==========================================
    // 3. VISUALS (Rocket View)
    // ==========================================
    function initThree() {
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x0b0b15, 0.02); // Depth cue

        // Camera is looking STRAIGHT DOWN
        camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 40); 
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 0.8);
        light.position.set(10, 10, 50);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x444444));

        // Ground Group: Contains the plate and previous stack
        // This group MOVES relative to the camera to simulate sway
        groundGroup = new THREE.Group();
        scene.add(groundGroup);

        // The Launch Pad
        const padGeo = new THREE.PlaneGeometry(200, 200);
        const padMat = new THREE.MeshBasicMaterial({ color: 0x1a1a2a });
        const pad = new THREE.Mesh(padGeo, padMat);
        pad.position.z = -30; // Far below
        groundGroup.add(pad);

        // The Grid (Visual Reference for movement)
        const grid = new THREE.GridHelper(200, 50, 0x333333, 0x111111);
        grid.rotation.x = Math.PI/2;
        grid.position.z = -29;
        groundGroup.add(grid);

        stackGroup = new THREE.Group();
        groundGroup.add(stackGroup);

        // Active Mesh (Attached to Camera/Scene, NOT Ground)
        // It stays "with you" as you go up
        const geo = new THREE.PlaneGeometry(12, 12, NX-1, NY-1);
        const mat = new THREE.MeshStandardMaterial({ color: 0xffaa00, roughness: 0.4 });
        activeMesh = new THREE.Mesh(geo, mat);
        scene.add(activeMesh);
    }

    function updateVisuals() {
        // 1. Deform Active Mesh
        const pos = activeMesh.geometry.attributes.position.array;
        for(let i=0; i<NX*NY; i++) {
            let d = rho[i];
            let h = 0;
            if(d>1.1) h = (d-1.1)*5.0;
            pos[i*3+2] = h; // Z height
        }
        activeMesh.geometry.attributes.position.needsUpdate=true;

        // 2. THE ROCKET VIEW TRICK
        // The camera is effectively at Z=40 relative to the current layer.
        // The stack is below us.
        // We move the `groundGroup` (the stack) in X/Y based on physics tilt.
        
        // If tower leans, the bottom moves AWAY from center
        const swayX = -tiltX * 30.0; 
        const swayY = tiltY * 30.0; // Y inverted for ThreeJS coords
        
        groundGroup.position.x = swayX;
        groundGroup.position.y = swayY;
        
        // 3. Recede ground (Move it further away in Z as stack grows)
        // We actually just move the stack group down, so camera stays at 0
        const stackHeight = stack.length * 1.5; // Distance between layers
        
        // Smooth lerp for Z depth
        const targetZ = -stackHeight;
        groundGroup.position.z += (targetZ - groundGroup.position.z) * 0.1;
        
        // Visual fog enhances the "High Altitude" feel
    }

    function freezeLayer() {
        if(isGameOver) return;

        // Clone Active Layer
        const mesh = activeMesh.clone();
        mesh.material = activeMesh.material.clone();
        mesh.material.color.setHex(0xcc8800); // Cooked color
        
        // Add to stack group
        // Important: It gets added at Z=0 (top), then the whole group slides down
        // But we need to place it relative to the *current* ground group sway?
        // Actually, in this frame of reference, the new layer is perfectly aligned 
        // with the camera (0,0), but the stack below is offset.
        // So we add it at 0,0 relative to the StackGroup, BUT we must account for the sway difference?
        
        // Simplification: Just stack them in Z. The visual sway is global.
        mesh.position.z = stack.length * 1.5; 
        
        stackGroup.add(mesh);
        stack.push({});

        // Update HUD
        document.getElementById('score-text').innerText = stack.length + "m";
        document.getElementById('altitude-fill').style.height = Math.min(stack.length, 100) + "%";
        
        // Reset Fluid
        currentOmega = initLBM();
    }

    function gameOver() {
        isGameOver = true;
        document.querySelector('h1').innerText = "CONNECTION LOST";
        document.querySelector('p').innerText = `Final Altitude: ${stack.length}m`;
        document.getElementById('startBtn').innerText = "RE-IGNITE";
        document.getElementById('overlay').style.display = 'flex';
        
        // Spin effect
        new TWEEN.Tween(groundGroup.rotation)
            .to({ z: 5 }, 3000)
            .start();
    }

    // --- LOOP ---
    let currentOmega = 1.0;
    
    function animate(time) {
        requestAnimationFrame(animate);
        TWEEN.update(time);
        if(!isRunning || isGameOver) return;

        // Timer
        frameCount++;
        const progress = (frameCount % ADD_INTERVAL) / ADD_INTERVAL;
        document.querySelector('circle').style.strokeDashoffset = 157 * progress;

        if(frameCount % ADD_INTERVAL === 0) freezeLayer();

        stepLBM(currentOmega);
        updatePhysics();
        updateVisuals();
        
        renderer.render(scene, camera);
    }

    // --- INPUTS ---
    function handleOrient(e) {
        if(isGameOver) return;
        let x = e.gamma || 0; 
        let y = e.beta || 0; 
        
        // Flat Phone Logic
        // Clamp -30 to 30 degrees
        x = Math.max(-30, Math.min(30, x));
        y = Math.max(-30, Math.min(30, y));
        
        // Normalize -1 to 1
        inputX = x / 30; 
        inputY = y / 30;
    }
    
    // Mouse fallback
    function handleMouse(e) {
        inputX = (e.clientX / window.innerWidth) * 2 - 1;
        inputY = (e.clientY / window.innerHeight) * 2 - 1;
    }

    document.getElementById('startBtn').addEventListener('click', () => {
        if(isGameOver) location.reload();
        if(typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(r=>{if(r==='granted')window.addEventListener('deviceorientation', handleOrient)});
        } else {
            window.addEventListener('deviceorientation', handleOrient);
        }
        window.addEventListener('mousemove', handleMouse);

        document.getElementById('overlay').style.display = 'none';
        isRunning = true;
        initThree();
        currentOmega = initLBM();
        animate();
    });
    
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
