<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Rentensystem-Simulator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- MathJax v3 -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['\\(','\\)'], ['$', '$']],
        displayMath: [['\\[','\\]'], ['$$','$$']]
      },
      svg: { fontCache: 'global' }
    };
  </script>
  <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>

  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color-scheme: light dark;
      --bg: #0f172a;
      --fg: #e5e7eb;
      --accent: #38bdf8;
      --card: #111827;
      --muted: #9ca3af;
    }
    body {
      margin: 0;
      background: radial-gradient(circle at top, #1e293b 0, #020617 55%, #000 100%);
      color: var(--fg);
      min-height: 100vh;
      display: flex;
      align-items: stretch;
      justify-content: center;
    }
    .app {
      max-width: 1200px;
      width: 100%;
      padding: 16px 24px 32px;
      box-sizing: border-box;
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 1fr);
      gap: 16px;
    }
    header {
      grid-column: 1 / -1;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      margin-bottom: 4px;
      gap: 6px;
    }
    h1 {
      font-size: 1.5rem;
      margin: 0;
    }
    .subtitle {
      font-size: 0.9rem;
      color: var(--muted);
      margin-top: 2px;
    }
    .subtitle strong {
      color: var(--fg);
    }
    .subtitle a {
      color: var(--accent);
      text-decoration: none;
    }
    .subtitle a:hover {
      text-decoration: underline;
    }
    .math-inline {
      font-family: "SF Mono", "JetBrains Mono", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.95em;
      background: rgba(15, 23, 42, 0.6);
      padding: 0 3px;
      border-radius: 4px;
    }
    .math-block {
      margin-top: 4px;
      padding: 6px 10px;
      border-radius: 8px;
      background: linear-gradient(90deg, rgba(56, 189, 248, 0.1), rgba(15, 23, 42, 0.9));
      border: 1px solid rgba(56, 189, 248, 0.4);
      font-family: "SF Mono", "JetBrains Mono", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.98rem;
    }
    .card {
      background: rgba(15, 23, 42, 0.9);
      border-radius: 16px;
      padding: 16px 18px 18px;
      box-shadow: 0 18px 45px rgba(0, 0, 0, 0.45);
      backdrop-filter: blur(16px);
      border: 1px solid rgba(148, 163, 184, 0.25);
    }
    .card.full-width {
      grid-column: 1 / -1;
    }
    .card h2 {
      font-size: 1.05rem;
      margin: 0 0 10px;
    }
    .card h3 {
      font-size: 0.95rem;
      margin: 10px 0 6px;
    }
    .grid-2 {
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
      gap: 12px;
    }
    .field {
      margin-bottom: 10px;
    }
    .field label {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      font-size: 0.85rem;
      margin-bottom: 4px;
    }
    .field span.value {
      font-variant-numeric: tabular-nums;
      color: var(--muted);
      margin-left: 8px;
    }
    input[type="range"] {
      width: 100%;
    }
    input[type="number"] {
      width: 110px;
      padding: 4px 6px;
      border-radius: 6px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      background: rgba(15, 23, 42, 0.7);
      color: var(--fg);
      font-size: 0.85rem;
    }
    .outputs {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
      margin-top: 8px;
    }
    .metric {
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.3);
    }
    .metric-label {
      font-size: 0.75rem;
      color: var(--muted);
      margin-bottom: 3px;
    }
    .metric-value {
      font-size: 0.98rem;
      font-variant-numeric: tabular-nums;
    }
    .metric-tag {
      font-size: 0.7rem;
      color: var(--muted);
      margin-left: 4px;
    }
    .scenario-groups {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-top: 8px;
    }
    .scenario-group-title {
      font-size: 0.8rem;
      color: var(--muted);
      margin-top: 4px;
    }
    .scenarios {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 2px;
    }
    .scenario-btn {
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      padding: 4px 10px;
      font-size: 0.75rem;
      background: transparent;
      color: var(--fg);
      cursor: pointer;
      transition: background 0.15s, border-color 0.15s, transform 0.05s;
    }
    .scenario-btn:hover {
      background: rgba(56, 189, 248, 0.15);
      border-color: var(--accent);
    }
    .scenario-btn:active {
      transform: translateY(1px);
    }
    .scenario-btn.primary {
      background: rgba(56, 189, 248, 0.2);
      border-color: var(--accent);
    }
    #scenarioDescription {
      margin-top: 8px;
      font-size: 0.8rem;
      color: var(--muted);
      line-height: 1.4;
    }
    #scenarioMeta {
      margin-top: 4px;
      font-size: 0.78rem;
      color: var(--muted);
    }
    #tauContour {
      width: 100%;
      height: 320px;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: #020617;
      display: block;
    }
    /* Dynamik-Canvas */
    #qDynamics {
      width: 100%;
      height: 260px;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: #020617;
      display: block;
      margin-top: 8px;
    }
    .dyn-legend {
      margin-top: 4px;
      font-size: 0.78rem;
      color: var(--muted);
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }
    .dyn-legend-item {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    .dyn-legend-swatch {
      width: 10px;
      height: 10px;
      border-radius: 999px;
    }
    .dyn-legend-swatch.q {
      background: rgba(56, 189, 248, 0.9);
    }
    .dyn-legend-swatch.tau {
      background: rgba(250, 204, 21, 0.9);
    }

    .export-bar {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      margin-top: 8px;
      gap: 8px;
      flex-wrap: wrap;
    }
    .export-btn {
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      padding: 4px 10px;
      font-size: 0.8rem;
      background: rgba(15, 23, 42, 0.9);
      color: var(--fg);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .export-btn:hover {
      border-color: var(--accent);
      background: rgba(56, 189, 248, 0.15);
    }
    .sources-list {
      font-size: 0.8rem;
      color: var(--muted);
    }
    .sources-list ul {
      padding-left: 18px;
      margin: 4px 0 0;
    }
    .sources-list li {
      margin-bottom: 3px;
    }
    .sources-list a {
      color: var(--accent);
      text-decoration: none;
    }
    .sources-list a:hover {
      text-decoration: underline;
    }
    .legend-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.8rem;
      margin-top: 6px;
    }
    .legend-table th,
    .legend-table td {
      border-bottom: 1px solid rgba(148, 163, 184, 0.3);
      padding: 4px 6px;
      text-align: left;
    }
    .legend-table th {
      color: var(--muted);
      font-weight: 500;
    }
    .legend-table td:first-child {
      width: 90px;
      font-family: "SF Mono", "JetBrains Mono", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    .contour-caption {
      margin-top: 6px;
      font-size: 0.78rem;
      color: var(--muted);
      line-height: 1.35;
    }

    @media (max-width: 880px) {
      .app {
        grid-template-columns: minmax(0, 1fr);
      }
    }
    @media (max-width: 700px) {
      .grid-2 {
        grid-template-columns: minmax(0, 1fr);
        gap: 8px;
      }
      .outputs {
        grid-template-columns: minmax(0, 1fr);
      }
      .field label {
        flex-direction: column;
        align-items: flex-start;
        gap: 2px;
      }
      input[type="number"] {
        width: 100%;
      }
      .card {
        padding: 12px 12px 14px;
      }
      .app {
        padding: 12px 12px 20px;
      }
      #tauContour {
        height: 240px;
      }
      #qDynamics {
        height: 220px;
      }
    }
    @media (max-width: 500px) {
      header {
        align-items: flex-start;
      }
      h1 {
        font-size: 1.25rem;
      }
      #qDynamics {
        height: 200px;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Rentensystem-Simulator</h1>
      <div class="subtitle">
        <strong>Einfaches Umlage-Modell</strong> mit Erweiterung um Aktivrente \(\gamma\), private Vorsorge
        und ein dynamisches Demografie-Modell mit Erwerbsmigration.
      </div>
      <div class="math-block" style="margin-left:auto; margin-right:auto; text-align:center; max-width:300px;">
        \[
          \tau = \frac{q \cdot \rho_{\text{gesetz}} \cdot (1 - f)}{1 + \gamma q}
        \]
      </div>
      <div class="subtitle">
        mit <span class="math-inline">\(q = \dfrac{N_R}{N_C}\)</span>.
        Detaillierte Herleitung mit Aktivrente, privater Vorsorge und Dynamikmodell siehe
        <a href="#modell-details">Modellbeschreibung</a>.
      </div>
      <div class="subtitle">
        \(\tau\) ist der Beitragssatz (Anteil vom Bruttolohn), \(q\) das Verhältnis von
        Rentnern zu Beitragszahlern, \(\rho_{\text{gesetz}}\) das gesetzliche Rentenniveau (durchschnittliche
        Rente in&nbsp;% des Lohns), \(f\) der Anteil der Rentenausgaben, der
        aus Steuern finanziert wird, und \(\gamma\) misst die beitragspflichtige Erwerbsintensität
        der Rentner (Aktivrente). Eine zusätzliche private Rente wird über \(\rho_{\text{privat}}\) modelliert.
        Das dynamische Demografie-Modell koppelt \(N_C(t)\), \(N_R(t)\) mit einem
        Quellterm für Erwerbsmigration \(M_{\text{mig}}\).
      </div>
    </header>

    <!-- EINGABEN -->
    <section class="card">
      <h2>Eingaben</h2>
      <div class="grid-2">
        <div>
          <div class="field">
            <label>
              Beitragszahler \(N_C\) <span class="value" id="ncLabel"></span>
            </label>
            <input id="nc" type="range" min="10" max="60" step="1" />
          </div>
          <div class="field">
            <label>
              Rentner \(N_R\) <span class="value" id="nrLabel"></span>
            </label>
            <input id="nr" type="range" min="5" max="30" step="1" />
          </div>
          <div class="field">
            <label>
              Durchschnittslohn je Beitragszahler (k€ / Jahr)
              <span class="value" id="wLabel"></span>
            </label>
            <input id="w" type="range" min="20" max="80" step="1" />
          </div>
        </div>
        <div>
          <div class="field">
            <label>
              Gesetzliches Rentenniveau \(\rho_{\text{gesetz}}\) (% vom Lohn)
              <span class="value" id="rhoLabel"></span>
            </label>
            <input id="rho" type="range" min="30" max="60" step="1" />
          </div>
          <div class="field">
            <label>
              Steueranteil \(f\) (% der Rentenausgaben)
              <span class="value" id="fLabel"></span>
            </label>
            <input id="f" type="range" min="0" max="60" step="1" />
          </div>
          <div class="field">
            <label>
              Aktivrente \(\gamma\) (% zusätzliche Beitragskapazität der Rentner)
              <span class="value" id="gammaLabel"></span>
            </label>
            <input id="gamma" type="range" min="0" max="20" step="1" />
          </div>
          <div class="field">
            <label>
              Beitragssatz \(\tau\) vorgeben (optional, %)
              <span class="value" id="tauOverrideLabel">auto</span>
            </label>
            <input id="tauOverride" type="number" min="0" max="40" step="0.1"
                   placeholder="auto" />
          </div>
        </div>
      </div>

      <h3>Private Vorsorge (vereinfachtes Sparmodell)</h3>
      <div class="grid-2">
        <div>
          <div class="field">
            <label>
              Sparquote \(s\) (% vom Jahreslohn)
              <span class="value" id="sPrivLabel"></span>
            </label>
            <input id="sPriv" type="range" min="0" max="20" step="1" />
          </div>
          <div class="field">
            <label>
              reale Rendite \(r\) (% p.a.)
              <span class="value" id="rPrivLabel"></span>
            </label>
            <input id="rPriv" type="range" min="0" max="5" step="0.25" />
          </div>
        </div>
        <div>
          <div class="field">
            <label>
              Beitragsjahre \(T_C\) (Sparphase)
              <span class="value" id="TcPrivLabel"></span>
            </label>
            <input id="TcPriv" type="range" min="20" max="45" step="1" />
          </div>
          <div class="field">
            <label>
              Rentenjahre \(T_R\)
              <span class="value" id="TrPrivLabel"></span>
            </label>
            <input id="TrPriv" type="range" min="10" max="30" step="1" />
          </div>
        </div>
      </div>

      <div class="scenario-groups">
        <div>
          <div class="scenario-group-title">Aktuelle Situation & Gesetzgebung</div>
          <div class="scenarios">
            <button class="scenario-btn primary" data-scenario="statusQuoDE">
              Status quo (2024)
            </button>
            <button class="scenario-btn" data-scenario="rentenpaket">
              Rentenpaket Haltelinie (2031)
            </button>
          </div>
        </div>

        <div>
          <div class="scenario-group-title">Demografie, Aktivrente & Reformoptionen</div>
          <div class="scenarios">
            <button class="scenario-btn" data-scenario="demography2035">
              Demografie ohne Reform (2035)
            </button>
            <button class="scenario-btn" data-scenario="laterRetirement">
              Späterer Rentenbeginn / Aktivrente
            </button>
            <button class="scenario-btn" data-scenario="boomerSoli">
              „Boomer-Soli“ (hohe Steuerfinanzierung)
            </button>
          </div>
        </div>

        <div>
          <div class="scenario-group-title">Rentenmix & radikale Varianten (didaktisch)</div>
          <div class="scenarios">
            <button class="scenario-btn" data-scenario="lowBenefit">
              Niedriges gesetzl. Niveau + hohe private Vorsorge
            </button>
            <button class="scenario-btn" data-scenario="noTaxes">
              Keine Steuerfinanzierung \(f = 0\)
            </button>
            <button class="scenario-btn" data-scenario="maxTaxes">
              Hohe Steuerfinanzierung \(f = 60\,\%\)
            </button>
          </div>
        </div>
      </div>

      <div id="scenarioMeta"></div>
      <div id="scenarioDescription"></div>
    </section>

    <!-- ERGEBNISSE & KONTURPLOT -->
    <section class="card">
      <h2>Ergebnisse</h2>
      <div class="outputs">
        <div class="metric">
          <div class="metric-label">Erforderlicher Beitragssatz \(\tau\)</div>
          <div class="metric-value">
            <span id="tauOut"></span> %
            <span class="metric-tag">(Modell, mit \(\gamma\))</span>
          </div>
        </div>
        <div class="metric">
          <div class="metric-label">Impliziter Steueranteil \(f\)</div>
          <div class="metric-value">
            <span id="fOut"></span> %
            <span class="metric-tag">(aus vorgegebenem \(\tau\))</span>
          </div>
        </div>
        <div class="metric">
          <div class="metric-label">Rentenausgaben \(A\)</div>
          <div class="metric-value"><span id="AOut"></span> Mrd. €</div>
        </div>
        <div class="metric">
          <div class="metric-label">Beitragsvolumen \(B\)</div>
          <div class="metric-value"><span id="BOut"></span> Mrd. €</div>
        </div>
        <div class="metric">
          <div class="metric-label">Steuerzuschuss \(S\)</div>
          <div class="metric-value"><span id="SOut"></span> Mrd. €</div>
        </div>
        <div class="metric">
          <div class="metric-label">Abhängigkeitsquotient \(q = N_R/N_C\)</div>
          <div class="metric-value"><span id="qOut"></span></div>
        </div>
        <div class="metric">
          <div class="metric-label">Gesetzliches Rentenniveau \(\rho_{\text{gesetz}}\)</div>
          <div class="metric-value"><span id="rhoGesOut"></span> %</div>
        </div>
        <div class="metric">
          <div class="metric-label">Private Ersatzrate \(\rho_{\text{privat}}\)</div>
          <div class="metric-value"><span id="rhoPrivOut"></span> %</div>
        </div>
        <div class="metric">
          <div class="metric-label">Gesamt-Ersatzrate \(\rho_{\text{gesamt}}\)</div>
          <div class="metric-value"><span id="rhoTotOut"></span> %</div>
        </div>
        <div class="metric">
          <div class="metric-label">Private Jahresrente \(P_{\text{privat}}\)</div>
          <div class="metric-value"><span id="PprivOut"></span> k€</div>
        </div>
        <div class="metric">
          <div class="metric-label">Kapital bei Renteneintritt \(K\)</div>
          <div class="metric-value"><span id="KprivOut"></span> k€</div>
        </div>
      </div>

      <h3 style="margin-top:12px;">Konturdiagramm \(\tau(q,f)\)</h3>

      <canvas id="tauContour"></canvas>
      <div class="contour-caption" id="contourCaption">
        Farbskala: Beitragssatz \(\tau\) in Prozent. x-Achse: Abhängigkeitsquotient
        <span class="math-inline">\(q = N_R/N_C\)</span> (mehr Rentner pro Beitragszahler nach rechts),
        y-Achse: Steueranteil <span class="math-inline">\(f\)</span> (mehr Steuerfinanzierung nach oben).<br/>
        Der weiße Punkt markiert die aktuelle Konfiguration der Eingaben \((q, f)\).<br/>
        Iso-Linien zeigen Kombinationen aus \(q\), \(f\) und Aktivrente \(\gamma\), die zu ähnlichen
        Beitragssätzen \(\tau\) führen. Die private Vorsorge \(\rho_{\text{privat}}\) wirkt auf einer
        zweiten Ebene: Sie verändert das gesamte Alterseinkommen, aber nicht direkt die Umlageformel.
      </div>

      <div class="export-bar">
        <button id="exportChartBtn" class="export-btn">
          Grafik als PNG exportieren
        </button>
      </div>
    </section>

    <!-- DYNAMISCHES MODELL -->
    <section class="card full-width" id="dynamics">
      <h2>Dynamisches Demografie-Modell: Umlage & Erwerbsmigration</h2>

      <h3>Dynamik-Parameter (vereinfachtes Jahresmodell)</h3>
      <div class="grid-2">
        <div>
          <div class="field">
            <label>
              Horizont \(T\) (Jahre)
              <span class="value" id="TdynLabel"></span>
            </label>
            <input id="Tdyn" type="range" min="0" max="40" step="1" />
          </div>
          <div class="field">
            <label>
              Netto-Wachstumsrate Beitragszahler \(g_C\) (% p.a.)
              <span class="value" id="gCLabel"></span>
            </label>
            <input id="gC" type="range" min="-2" max="2" step="0.1" />
          </div>
        </div>
        <div>
          <div class="field">
            <label>
              Netto-Wachstumsrate Rentner \(g_R\) (% p.a.)
              <span class="value" id="gRLabel"></span>
            </label>
            <input id="gR" type="range" min="0" max="3" step="0.1" />
          </div>
          <div class="field">
            <label>
              Erwerbsmigration \(M_{\text{mig}}\) (Mio. Personen / Jahr)
              <span class="value" id="MLabel"></span>
            </label>
            <input id="Mdyn" type="range" min="0" max="1.5" step="0.05" />
          </div>
        </div>
      </div>

      <div class="outputs">
        <div class="metric">
          <div class="metric-label">Abhängigkeitsquotient am Horizont \(q(T)\)</div>
          <div class="metric-value"><span id="qEndOut"></span></div>
        </div>
        <div class="metric">
          <div class="metric-label">Beitragssatz am Horizont \(\tau(T)\)</div>
          <div class="metric-value"><span id="tauEndOut"></span> %</div>
        </div>
        <div class="metric">
          <div class="metric-label">Rentenausgaben am Horizont \(A(T)\)</div>
          <div class="metric-value"><span id="AEndOut"></span> Mrd. €</div>
        </div>
        <div class="metric">
          <div class="metric-label">Steuerzuschuss am Horizont \(S(T)\)</div>
          <div class="metric-value"><span id="SEndOut"></span> Mrd. €</div>
        </div>
      </div>

      <canvas id="qDynamics"></canvas>
      <div class="dyn-legend">
        <div class="dyn-legend-item">
          <span class="dyn-legend-swatch q"></span> q(t) = N<span style="font-size:0.75em;">R</span>/N<span style="font-size:0.75em;">C</span> (linke Achse)
        </div>
        <div class="dyn-legend-item">
          <span class="dyn-legend-swatch tau"></span> τ(t) (rechte Achse, in %)
        </div>
      </div>
      <div class="export-bar">
      <button id="exportDynBtn" class="export-btn">
      Zeitpfade als PNG exportieren
      </button>
      </div>
      <div class="contour-caption" id="dynCaption">
        Zeitentwicklung von \(q(t) = N_R(t)/N_C(t)\) und dem dazugehörigen Beitragssatz \(\tau(t)\).
        Ausgangspunkt sind die oben gewählten Werte für \(N_C\) und \(N_R\). Das letzte Jahr \(T\) wird
        als Punkt hervorgehoben; die Kennzahlen \(q(T)\), \(\tau(T)\), \(A(T)\) und \(S(T)\) stehen oben
        als Zahlen.<br/>
        Die Dynamik folgt einem einfachen Jahresmodell mit Wachstumsraten \(g_C, g_R\) und einem
        Quellterm für Erwerbsmigration \(M_{\text{mig}}\), der jährlich zur Gruppe der
        Beitragszahler hinzukommt (\(N_C\) in Mio.). Bei gegebenem politischen Setting
        \((\rho_{\text{gesetz}}, f, \gamma)\) bestimmt \(q(t)\) direkt die Entwicklung von
        Beitragssatz \(\tau(t)\), Rentenausgaben \(A(t)\) und Steuerzuschuss \(S(t)\).<br/>
        Damit lassen sich z.&nbsp;B. Szenarien „mehr Steuerfinanzierung heute“ vs. „gezielte Investitionen in
        Erwerbsmigration“ vergleichen.
      </div>
    </section>

    <!-- MODELLBESCHREIBUNG & QUELLEN -->
    <section class="card full-width" id="modell-details">
      <h2>Modellbeschreibung & Quellen</h2>

      <h3>Symbollegende</h3>
      <table class="legend-table">
        <thead>
          <tr>
            <th>Symbol</th>
            <th>Bedeutung</th>
          </tr>
        </thead>
        <tbody>
          <tr><td>\(\tau\)</td><td>Beitragssatz (Anteil vom Bruttolohn)</td></tr>
          <tr><td>\(q\)</td>
              <td>Abhängigkeitsquotient,
                <span class="math-inline">\(q = \dfrac{N_R}{N_C}\)</span>
              </td></tr>
          <tr><td>\(\rho_{\text{gesetz}}\)</td><td>Gesetzliches Rentenniveau (Verhältnis durchschnittliche gesetzliche Rente / durchschnittlicher Lohn)</td></tr>
          <tr><td>\(\rho_{\text{privat}}\)</td><td>Ersatzrate aus privater Vorsorge (Verhältnis zusätzliche private Jahresrente / durchschnittlicher Lohn)</td></tr>
          <tr><td>\(\rho_{\text{gesamt}}\)</td><td>Gesamt-Ersatzrate im Alter,
            <span class="math-inline">\(\rho_{\text{gesamt}} = \rho_{\text{gesetz}} + \rho_{\text{privat}}\)</span></td></tr>
          <tr><td>\(f\)</td><td>Steueranteil an den Rentenausgaben (z.&nbsp;B. Bundeszuschüsse)</td></tr>
          <tr><td>\(\gamma\)</td><td>Aktivrente-Parameter: beitragspflichtige Erwerbsintensität der Rentner (in Einheiten von Vollzeit; z.&nbsp;B. \(\gamma=0{,}1\) bedeutet effektiv 10&nbsp;% zusätzliche Vollzeitbeitragszahler je 100 Rentner)</td></tr>
          <tr><td>\(N_C\)</td><td>Anzahl der Beitragszahler (im Tool in Mio.)</td></tr>
          <tr><td>\(N_R\)</td><td>Anzahl der Rentnerinnen und Rentner (im Tool in Mio.)</td></tr>
          <tr><td>\(\bar w\)</td><td>Durchschnittlicher Jahreslohn pro Beitragszahler</td></tr>
          <tr><td>\(\bar p\)</td><td>Durchschnittliche Jahresrente pro Rentner (gesetzliche Säule)</td></tr>
          <tr><td>\(A\)</td><td>Gesamte Rentenausgaben (gesetzliche Säule)</td></tr>
          <tr><td>\(B\)</td><td>Beitragsaufkommen (Summe der Beitragseinnahmen aus Erwerbsarbeit inkl. Aktivrente)</td></tr>
          <tr><td>\(S\)</td><td>Steuerzuschuss (vom Staat aufgebrachter Anteil)</td></tr>
          <tr><td>\(s\)</td><td>Sparquote für private Vorsorge (Anteil des Lohns, der privat gespart wird)</td></tr>
          <tr><td>\(r\)</td><td>Reale Verzinsung der privaten Ersparnisse (p.a.)</td></tr>
          <tr><td>\(T_C\)</td><td>Dauer der Sparphase (Beitragsjahre)</td></tr>
          <tr><td>\(T_R\)</td><td>Dauer der Rentenphase (Rentenjahre)</td></tr>
          <tr><td>\(K\)</td><td>Privates Kapital bei Renteneintritt</td></tr>
          <tr><td>\(P_{\text{privat}}\)</td><td>Jährliche private Rente (Annuität aus \(K\))</td></tr>
          <tr><td>\(g_C\)</td><td>Netto-Wachstumsrate der Beitragszahler (in % p.a.)</td></tr>
          <tr><td>\(g_R\)</td><td>Netto-Wachstumsrate der Rentner (in % p.a.)</td></tr>
          <tr><td>\(M_{\text{mig}}\)</td><td>Quellterm „Erwerbsmigration“ (Zugang in den Arbeitsmarkt in Mio. Personen pro Jahr)</td></tr>
          <tr><td>\(T\)</td><td>Simulationshorizont des Dynamikmodells (Jahre)</td></tr>
        </tbody>
      </table>

      <h3>Herleitung des einfachen Umlage-Modells</h3>
      <p class="sources-list" style="line-height:1.45;">
        Im Umlageverfahren werden die laufenden Renten aus den laufenden Beiträgen
        und Steuerzuschüssen finanziert. Sei \(N_C\) die Zahl der Beitragszahler,
        \(N_R\) die Zahl der Rentner, \(\bar w\) der durchschnittliche Jahreslohn
        pro Beitragszahler, \(\bar p\) die durchschnittliche Jahresrente pro Rentner,
        \(\tau\) der Beitragssatz und \(f\) der Anteil der Rentenausgaben, der aus
        Steuern finanziert wird.
      </p>
      <p class="sources-list" style="line-height:1.45;">
        Gesamtausgaben für gesetzliche Renten:
        <span class="math-inline">\(A = N_R \cdot \bar p\)</span>.<br/>
        Einnahmen aus Beiträgen (ohne Aktivrente):
        <span class="math-inline">\(E_{\text{Beitrag}} = \tau \cdot \bar w \cdot N_C\)</span>.<br/>
        Steuerzuschuss:
        <span class="math-inline">\(E_{\text{Steuer}} = f \cdot A\)</span>.<br/>
        Es gilt:
        <span class="math-inline">\(E_{\text{Beitrag}} + E_{\text{Steuer}} = A\)</span>.
      </p>
      <p class="sources-list" style="line-height:1.45%;">
        Einsetzen und Umformen ergibt:
      </p>
      <div class="math-block" style="margin-left:auto; margin-right:auto; text-align:center; max-width:300px;">
        \[
        \tau \,\bar w\, N_C + f\, N_R\, \bar p = N_R\, \bar p
        \]
        \[
        \Rightarrow \quad
        \tau = \frac{N_R}{N_C} \cdot \frac{\bar p}{\bar w} \cdot (1 - f)
        \]
      </div>
      <p class="sources-list" style="line-height:1.45%;">
        Definiert man das gesetzliche Rentenniveau
        \(\rho_{\text{gesetz}} = \bar p / \bar w\) und den Abhängigkeitsquotienten
        \(q = N_R / N_C\), erhält man das einfache Umlage-Modell:
      </p>
      <div class="math-block" style="margin-left:auto; margin-right:auto; text-align:center; max-width:300px;">
        \[
        \tau = q \cdot \rho_{\text{gesetz}} \cdot (1 - f)
        \]
      </div>
      <p class="sources-list" style="line-height:1.45%;">
        Dieses Modell nimmt implizit an, dass Rentner keine Beiträge zahlen und alle Beitragszahler
        nicht im Rentenbezug sind. Steigt \(q\) (mehr Rentner pro Beitragszahler), bleibt
        \(\rho_{\text{gesetz}}\) hoch und \(f\) niedrig, muss \(\tau\) steigen.
      </p>

      <h3>Erweiterung: Aktivrente \(\gamma\)</h3>
      <p class="sources-list" style="line-height:1.45%;">
        Mit Aktivrente wird angenommen, dass ein Teil der Rentner weiter arbeitet und Beiträge zahlt.
        Sei \(\gamma\) die beitragspflichtige Erwerbsintensität der Rentner, gemessen in Einheiten von
        Vollzeitbeschäftigung: \(\gamma N_R\) verhält sich also so, als gäbe es so viele zusätzliche
        „virtuelle“ Vollzeit-Beitragszahler.
      </p>
      <p class="sources-list" style="line-height:1.45%;">
        Dann ist die beitragspflichtige Lohnsumme
        <span class="math-inline">\(L = \bar w \,(N_C + \gamma N_R)\)</span> und die Beitragseinnahmen sind
        <span class="math-inline">\(E_{\text{Beitrag}} = \tau \, L = \tau \,\bar w\,(N_C + \gamma N_R)\)</span>.
        Mit \(A = N_R \bar p\) und \(E_{\text{Steuer}} = fA\) gilt:
      </p>
      <div class="math-block" style="margin-left:auto; margin-right:auto; text-align:center; max-width:500px;">
        \[
        \tau \,\bar w\,(N_C + \gamma N_R) + f\, N_R \bar p = N_R \bar p
        \]
        \[
        \Rightarrow \quad
        \tau \,\bar w\,(N_C + \gamma N_R) = (1-f) N_R \bar p
        \]
        \[
        \Rightarrow \quad
        \tau = \frac{N_R}{N_C} \cdot \frac{\bar p}{\bar w} \cdot \frac{(1-f)}{1 + \gamma \frac{N_R}{N_C}}
        = \frac{q \cdot \rho_{\text{gesetz}} \cdot (1-f)}{1 + \gamma q}
        \]
      </div>
      <p class="sources-list" style="line-height:1.45%;">
        Für \(\gamma = 0\) erhält man wieder das einfache Umlage-Modell.
        Je größer \(\gamma\), desto stärker verschiebt die Aktivrente die demografische Last, weil ein Teil der
        Rentner wieder zur Beitragsbasis gehört.
      </p>

      <h3>Modellansatz Eigenvorsorge: private Ersatzrate \(\rho_{\text{privat}}\)</h3>
      <p class="sources-list" style="line-height:1.45%;">
        Zusätzlich wird eine private Vorsorgesäule modelliert: Individuen sparen jedes Jahr einen Anteil
        \(s\) ihres Lohns, erzielen eine reale Rendite \(r\) und beziehen später aus dem angesparten Kapital
        eine private Rente. Dieses Vorsorgemodell wirkt auf einer <strong>anderen Ebene</strong>:
        Die Umlageformel bestimmt die Finanzierungslogik der gesetzlichen Säule, während die private Säule
        das Gesamtalterseinkommen ergänzt.
      </p>
      <p class="sources-list" style="line-height:1.45%;">
        Annahmen:
      </p>
      <ul class="sources-list">
        <li>Jährliche Sparleistung: \(s \,\bar w\).</li>
        <li>Sparphase über \(T_C\) Jahre mit realer Rendite \(r\).</li>
        <li>Rentenphase über \(T_R\) Jahre; das angesparte Kapital wird als Annuität verrentet.</li>
      </ul>
      <p class="sources-list" style="line-height:1.45%;">
        Kapital bei Renteneintritt:
        <span class="math-inline">
          \(K = s \,\bar w \,\dfrac{(1+r)^{T_C} - 1}{r}\)
        </span>
        (für \(r &gt; 0\); für \(r=0\) reduziert sich das auf \(K = s \,\bar w\, T_C\)).
        Die jährliche private Rente als Annuität ist
        <span class="math-inline">
          \(P_{\text{privat}} = K \cdot \dfrac{r}{1 - (1+r)^{-T_R}}\)
        </span>.
      </p>
      <p class="sources-list" style="line-height:1.45%;">
        Die private Ersatzrate ist dann
      </p>
      <div class="math-block" style="margin-left:auto; margin-right:auto; text-align:center; max-width:300px;">
        \[
        \rho_{\text{privat}} = \frac{P_{\text{privat}}}{\bar w}
        = s \cdot \frac{[(1+r)^{T_C} - 1]/r}{1 - (1+r)^{-T_R}}.
        \]
      </div>
      <p class="sources-list" style="line-height:1.45%;">
        Die Gesamt-Ersatzrate im Alter ergibt sich aus gesetzlicher und privater Säule:
        <span class="math-inline">\(\rho_{\text{gesamt}} = \rho_{\text{gesetz}} + \rho_{\text{privat}}\)</span>.
      </p>

      <h3>Dynamisches Demografie-Modell mit Erwerbsmigration</h3>
      <p class="sources-list" style="line-height:1.45%;">
        Um nicht nur statische Zustände, sondern die Entwicklung des Systems zu untersuchen, wird das
        Umlage-Modell mit einem einfachen <strong>dynamischen Demografie-Modell</strong> gekoppelt.
        Ausgangspunkt sind die aktuellen Werte \(N_C(0)\), \(N_R(0)\) aus den Slidern. Für jedes Jahr
        \(t = 0, 1, \dots, T-1\) gilt:
      </p>
      <div class="math-block" style="margin-left:auto; margin-right:auto; text-align:center; max-width:450px;">
        \[
          N_C(t+1) = N_C(t)\,\bigl(1 + g_C\bigr) + M_{\text{mig}},
        \]
        \[
          N_R(t+1) = N_R(t)\,\bigl(1 + g_R\bigr),
        \]
        \[
          q(t) = \frac{N_R(t)}{N_C(t)}.
        \]
      </div>
      <p class="sources-list" style="line-height:1.45%;">
        Die Parameter bedeuten:
      </p>
      <ul class="sources-list">
        <li>\(g_C\): Netto-Wachstumsrate der Beitragszahler (in % p.a.).</li>
        <li>\(g_R\): Netto-Wachstumsrate der Rentner (in % p.a.).</li>
        <li>\(M_{\text{mig}}\): jährlicher <strong>Quellterm für Erwerbsmigration</strong> (Mio. Personen pro Jahr),
            die in den beitragspflichtigen Arbeitsmarkt eintreten.</li>
      </ul>
      <p class="sources-list" style="line-height:1.45%;">
        Für jedes Jahr \(t\) wird aus \(q(t)\) mit den gewählten politischen Parametern
        \(\rho_{\text{gesetz}}, f, \gamma\) eine Folge von Beitragssätzen \(\tau(t)\),
        Rentenausgaben \(A(t)\) und Steuerzuschüssen \(S(t)\) berechnet:
      </p>
      <div class="math-block" style="margin-left:auto; margin-right:auto; text-align:center; max-width:450px;">
        \[
          \tau(t) = \frac{q(t) \cdot \rho_{\text{gesetz}} \cdot (1 - f)}{1 + \gamma\,q(t)},
        \qquad
          A(t) = N_R(t)\,\rho_{\text{gesetz}}\,\bar w,
        \qquad
          S(t) = A(t) - \tau(t)\,\bar w\,(N_C(t) + \gamma N_R(t)).
        \]
      </div>
      <p class="sources-list" style="line-height:1.45%;">
        Im Tool werden die Pfade \(q(t)\) und \(\tau(t)\) in einem gemeinsamen Diagramm geplottet
        (linke bzw. rechte y-Achse). Für das letzte Jahr \(T\) werden \(q(T)\), \(\tau(T)\),
        \(A(T)\) und \(S(T)\) zusätzlich als Kennzahlen ausgeben.
      </p>

      <h3>Konturdiagramm \(\tau(q,f)\)</h3>
      <p class="sources-list" style="line-height:1.45%;">
        Das Konturdiagramm zeigt den Beitragssatz \(\tau\) in Abhängigkeit vom Abhängigkeitsquotienten
        \(q = N_R/N_C\) (x-Achse) und dem Steueranteil \(f\) (y-Achse) für das aktuell gewählte gesetzliche
        Rentenniveau \(\rho_{\text{gesetz}}\) und die Aktivrente \(\gamma\).
      </p>

      <h3>Datengrundlagen der voreingestellten Szenarien</h3>
      <p class="sources-list">
        Die voreingestellten Werte sind gerundete, didaktisch vereinfachte Größen
        und dienen der Illustration.
      </p>
      <div class="sources-list">
        <ul>
          <li><a href="https://jahresbericht.deutsche-rentenversicherung.de/" target="_blank" rel="noopener">Deutsche Rentenversicherung – Jahresbericht</a></li>
          <li><a href="https://www.deutsche-rentenversicherung.de/DRV/DE/Experten/Statistiken-und-Berichte/Statistikpublikationen/statistikpublikationen_node.html" target="_blank" rel="noopener">„Rentenversicherung in Zahlen“</a></li>
          <li><a href="https://www.destatis.de/DE/Themen/Querschnitt/Demografischer-Wandel/_inhalt.html" target="_blank" rel="noopener">Destatis – Demografischer Wandel</a></li>
        </ul>
      </div>
      <p class="sources-list" style="margin-top:6px;">
        Last update: 2025-11-18 · Author: Robert Flassig · MIT License · Created with AI-assisted coding
      </p>
    </section>
  </div>

  <script>
    const fmtPct = (x) => (isFinite(x) ? x.toFixed(1) : "–");
    const fmtBn  = (x) => (isFinite(x) ? x.toFixed(1) : "–");
    const fmtRat = (x) => (isFinite(x) ? x.toFixed(3) : "–");
    const fmtK   = (x) => (isFinite(x) ? x.toFixed(1) : "–");

    const nc       = document.getElementById("nc");
    const nr       = document.getElementById("nr");
    const w        = document.getElementById("w");
    const rho      = document.getElementById("rho");
    const f        = document.getElementById("f");
    const gamma    = document.getElementById("gamma");
    const tauOv    = document.getElementById("tauOverride");

    const sPriv    = document.getElementById("sPriv");
    const rPriv    = document.getElementById("rPriv");
    const TcPriv   = document.getElementById("TcPriv");
    const TrPriv   = document.getElementById("TrPriv");

    const ncLabel  = document.getElementById("ncLabel");
    const nrLabel  = document.getElementById("nrLabel");
    const wLabel   = document.getElementById("wLabel");
    const rhoLabel = document.getElementById("rhoLabel");
    const fLabel   = document.getElementById("fLabel");
    const gammaLabel = document.getElementById("gammaLabel");
    const tauOvLbl = document.getElementById("tauOverrideLabel");

    const sPrivLabel  = document.getElementById("sPrivLabel");
    const rPrivLabel  = document.getElementById("rPrivLabel");
    const TcPrivLabel = document.getElementById("TcPrivLabel");
    const TrPrivLabel = document.getElementById("TrPrivLabel");

    const tauOut = document.getElementById("tauOut");
    const fOut   = document.getElementById("fOut");
    const AOut   = document.getElementById("AOut");
    const BOut   = document.getElementById("BOut");
    const SOut   = document.getElementById("SOut");
    const qOut   = document.getElementById("qOut");

    const rhoGesOut = document.getElementById("rhoGesOut");
    const rhoPrivOut = document.getElementById("rhoPrivOut");
    const rhoTotOut = document.getElementById("rhoTotOut");
    const PprivOut  = document.getElementById("PprivOut");
    const KprivOut  = document.getElementById("KprivOut");

    const scenarioDescription = document.getElementById("scenarioDescription");
    const scenarioMeta = document.getElementById("scenarioMeta");
    const contourCanvas = document.getElementById("tauContour");
    const exportChartBtn = document.getElementById("exportChartBtn");

    const Tdyn     = document.getElementById("Tdyn");
    const gCSlider = document.getElementById("gC");
    const gRSlider = document.getElementById("gR");
    const Mdyn     = document.getElementById("Mdyn");

    const TdynLabel = document.getElementById("TdynLabel");
    const gCLabel   = document.getElementById("gCLabel");
    const gRLabel   = document.getElementById("gRLabel");
    const MLabel    = document.getElementById("MLabel");

    const qEndOut  = document.getElementById("qEndOut");
    const tauEndOut = document.getElementById("tauEndOut");
    const AEndOut  = document.getElementById("AEndOut");
    const SEndOut  = document.getElementById("SEndOut");

    const qDynCanvas = document.getElementById("qDynamics");

    const scenarioTexts = {
      statusQuoDE: {
        title: "Status quo (2024)",
        year: "2024",
        desc: "Heutige Größenordnung: ca. 40 Mio. Beitragszahler, 21 Mio. Rentner, Durchschnittslohn 50 k€, gesetzliches Rentenniveau 48 %, Steueranteil 30 %, geringe Aktivrente und moderate private Vorsorge."
      },
      rentenpaket: {
        title: "Rentenpaket: Haltelinie 48 % (bis 2031)",
        year: "2031",
        desc: "Haltelinie beim Rentenniveau, höherer Steueranteil und leicht veränderte Demografie."
      },
      demography2035: {
        title: "Demografie 2035 ohne Reform",
        year: "2035",
        desc: "Ungünstigere Altersstruktur, kaum zusätzliche Aktivrente oder Migration."
      },
      laterRetirement: {
        title: "Reform: späterer Rentenbeginn / Aktivrente",
        year: "ca. 2035+",
        desc: "Mehr Erwerbsbeteiligung Älterer und etwas höhere Erwerbsmigration."
      },
      boomerSoli: {
        title: "„Boomer-Soli“: höherer Steueranteil",
        year: "2030er",
        desc: "Starker Steuerzuschuss, Beitragssatz politisch gedeckelt."
      },
      lowBenefit: {
        title: "Rentenmix: niedriges gesetzliches Niveau + hohe private Vorsorge",
        year: "theoretisch",
        desc: "Stärkere Verlagerung auf private Säule, geringeres gesetzliches Niveau."
      },
      noTaxes: {
        title: "Radikal: keine Steuerfinanzierung f = 0",
        year: "theoretisch",
        desc: "Alle Renten rein beitragsfinanziert, hoher demografischer Druck."
      },
      maxTaxes: {
        title: "Radikal: hohe Steuerfinanzierung f = 60 %",
        year: "theoretisch",
        desc: "Großer Steuerzuschuss, niedriger Beitragssatz, hohe Staatslast."
      }
    };

    function applyScenario(name) {
      if (name === "statusQuoDE") {
        nc.value = 40;
        nr.value = 21;
        w.value = 50;
        rho.value = 48;
        f.value = 30;
        gamma.value = 2;
        tauOv.value = "";
        sPriv.value = 5;
        rPriv.value = 2;
        TcPriv.value = 40;
        TrPriv.value = 20;

        Tdyn.value = 20;
        gCSlider.value = 0.0;
        gRSlider.value = 1.2;
        Mdyn.value = 0.3;
      } else if (name === "rentenpaket") {
        nc.value = 38;
        nr.value = 22;
        w.value = 51;
        rho.value = 48;
        f.value = 35;
        gamma.value = 3;
        tauOv.value = "";
        sPriv.value = 6;
        rPriv.value = 2;
        TcPriv.value = 40;
        TrPriv.value = 20;

        Tdyn.value = 20;
        gCSlider.value = -0.2;
        gRSlider.value = 1.3;
        Mdyn.value = 0.3;
      } else if (name === "demography2035") {
        nc.value = 40;
        nr.value = 20;
        w.value = 52;
        rho.value = 48;
        f.value = 30;
        gamma.value = 2;
        tauOv.value = "";
        sPriv.value = 5;
        rPriv.value = 2;
        TcPriv.value = 40;
        TrPriv.value = 20;

        Tdyn.value = 20;
        gCSlider.value = -0.3;
        gRSlider.value = 1.5;
        Mdyn.value = 0.1;
      } else if (name === "laterRetirement") {
        nc.value = 42;
        nr.value = 18;
        w.value = 52;
        rho.value = 48;
        f.value = 30;
        gamma.value = 6;
        tauOv.value = "";
        sPriv.value = 6;
        rPriv.value = 2.5;
        TcPriv.value = 42;
        TrPriv.value = 18;

        Tdyn.value = 20;
        gCSlider.value = 0.2;
        gRSlider.value = 1.0;
        Mdyn.value = 0.4;
      } else if (name === "boomerSoli") {
        nc.value = 40;
        nr.value = 21;
        w.value = 50;
        rho.value = 48;
        f.value = 40;
        gamma.value = 3;
        tauOv.value = 18.0;
        sPriv.value = 5;
        rPriv.value = 2;
        TcPriv.value = 40;
        TrPriv.value = 20;

        Tdyn.value = 20;
        gCSlider.value = -0.2;
        gRSlider.value = 1.3;
        Mdyn.value = 0.2;
      } else if (name === "lowBenefit") {
        nc.value = 40;
        nr.value = 21;
        w.value = 50;
        rho.value = 35;
        f.value = 30;
        gamma.value = 2;
        tauOv.value = "";
        sPriv.value = 10;
        rPriv.value = 3;
        TcPriv.value = 40;
        TrPriv.value = 20;

        Tdyn.value = 20;
        gCSlider.value = 0.0;
        gRSlider.value = 1.2;
        Mdyn.value = 0.3;
      } else if (name === "noTaxes") {
        nc.value = 40;
        nr.value = 21;
        w.value = 50;
        rho.value = 48;
        f.value = 0;
        gamma.value = 2;
        tauOv.value = "";
        sPriv.value = 5;
        rPriv.value = 2;
        TcPriv.value = 40;
        TrPriv.value = 20;

        Tdyn.value = 20;
        gCSlider.value = -0.3;
        gRSlider.value = 1.4;
        Mdyn.value = 0.3;
      } else if (name === "maxTaxes") {
        nc.value = 40;
        nr.value = 21;
        w.value = 50;
        rho.value = 48;
        f.value = 60;
        gamma.value = 2;
        tauOv.value = 15.0;
        sPriv.value = 5;
        rPriv.value = 2;
        TcPriv.value = 40;
        TrPriv.value = 20;

        Tdyn.value = 20;
        gCSlider.value = -0.1;
        gRSlider.value = 1.3;
        Mdyn.value = 0.3;
      }

      const meta = scenarioTexts[name];
      if (meta) {
        scenarioMeta.textContent = `Szenario: ${meta.title} (Jahr: ${meta.year})`;
        scenarioDescription.textContent = meta.desc;
      } else {
        scenarioMeta.textContent = "";
        scenarioDescription.textContent = "";
      }
      update();
    }

    function drawContour() {
      const ctx = contourCanvas.getContext("2d");
      const width = contourCanvas.clientWidth;
      const height = contourCanvas.clientHeight;
      contourCanvas.width = width * window.devicePixelRatio;
      contourCanvas.height = height * window.devicePixelRatio;
      ctx.setTransform(window.devicePixelRatio, 0, 0, window.devicePixelRatio, 0, 0);

      ctx.clearRect(0, 0, width, height);

      const paddingLeft = 55;
      const paddingRight = 70;
      const paddingTop = 20;
      const paddingBottom = 35;

      const plotW = width - paddingLeft - paddingRight;
      const plotH = height - paddingTop - paddingBottom;
      if (plotW <= 0 || plotH <= 0) return;

      const rhoLawPct = Number(rho.value);
      const rhoLawDec = rhoLawPct / 100;
      const fSliderPct = Number(f.value);
      const fCurr = fSliderPct / 100;

      const NC = Number(nc.value);
      const NR = Number(nr.value);
      const qCurr = NR / NC;

      const gammaDec = Number(gamma.value) / 100;

      const tauOverrideVal = tauOv.value === "" ? null : Number(tauOv.value);
      const useTauOv = tauOverrideVal !== null && !Number.isNaN(tauOverrideVal);

      const nx = 90;
      const ny = 90;

      let minTau = Infinity;
      let maxTau = -Infinity;
      const grid = [];

      const qSpan = 0.8;
      let qMin = Math.max(0.1, qCurr - qSpan / 2);
      let qMax = qMin + qSpan;

      const fSpan = 0.6;
      let fMin = Math.max(0.0, fCurr - fSpan / 2);
      let fMax = Math.min(0.8, fMin + fSpan);
      if (fMax - fMin < 0.2) {
        fMax = Math.min(0.8, fMin + 0.2);
      }

      for (let iy = 0; iy < ny; iy++) {
        const fVal = fMin + (iy / (ny - 1)) * (fMax - fMin);
        const row = [];
        for (let ix = 0; ix < nx; ix++) {
          const qVal = qMin + (ix / (nx - 1)) * (qMax - qMin);
          const tauDec = (qVal * rhoLawDec * (1 - fVal)) / (1 + gammaDec * qVal);
          const tauPct = tauDec * 100;
          row.push(tauPct);
          if (tauPct < minTau) minTau = tauPct;
          if (tauPct > maxTau) maxTau = tauPct;
        }
        grid.push(row);
      }

      if (!isFinite(minTau) || !isFinite(maxTau) || maxTau <= minTau) {
        minTau = 0;
        maxTau = 30;
      }

      for (let iy = 0; iy < ny - 1; iy++) {
        const fVal0 = fMin + (iy / (ny - 1)) * (fMax - fMin);
        const fVal1 = fMin + ((iy + 1) / (ny - 1)) * (fMax - fMin);
        const y0 = paddingTop + (1 - (fVal0 - fMin) / (fMax - fMin)) * plotH;
        const y1 = paddingTop + (1 - (fVal1 - fMin) / (fMax - fMin)) * plotH;
        const cellH = y1 - y0;

        for (let ix = 0; ix < nx - 1; ix++) {
          const qVal0 = qMin + (ix / (nx - 1)) * (qMax - qMin);
          const qVal1 = qMin + ((ix + 1) / (nx - 1)) * (qMax - qMin);
          const x0 = paddingLeft + ((qVal0 - qMin) / (qMax - qMin)) * plotW;
          const x1 = paddingLeft + ((qVal1 - qMin) / (qMax - qMin)) * plotW;
          const cellW = x1 - x0;

          const tauCell = grid[iy][ix];
          const norm = (tauCell - minTau) / (maxTau - minTau);
          const h = (1 - norm) * 240;
          ctx.fillStyle = `hsl(${h}, 80%, 50%)`;
          ctx.fillRect(x0, y1, cellW, -cellH);
        }
      }

      ctx.strokeStyle = "rgba(148,163,184,0.8)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(paddingLeft, paddingTop);
      ctx.lineTo(paddingLeft, paddingTop + plotH);
      ctx.lineTo(paddingLeft + plotW, paddingTop + plotH);
      ctx.stroke();

      ctx.fillStyle = "rgba(148,163,184,0.9)";
      ctx.font = "10px system-ui";

      const qTicks = 4;
      for (let i = 0; i <= qTicks; i++) {
        const t = i / qTicks;
        const qVal = qMin + t * (qMax - qMin);
        const x = paddingLeft + t * plotW;
        const y = paddingTop + plotH;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x, y + 4);
        ctx.stroke();
        ctx.fillText(qVal.toFixed(2), x - 10, y + 14);
      }
      ctx.fillText("q = N_R / N_C", paddingLeft + plotW / 2 - 25, paddingTop + plotH + 26);

      const fTicks = 4;
      for (let i = 0; i <= fTicks; i++) {
        const t = i / fTicks;
        const fVal = fMin + t * (fMax - fMin);
        const y = paddingTop + (1 - t) * plotH;
        const x = paddingLeft;
        ctx.beginPath();
        ctx.moveTo(x - 4, y);
        ctx.lineTo(x, y);
        ctx.stroke();
        ctx.fillText((fVal * 100).toFixed(0) + "%", x - 32, y + 3);
      }
      ctx.save();
      ctx.translate(paddingLeft - 38, paddingTop + plotH / 2 + 15);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText("Steueranteil f", 0, 0);
      ctx.restore();

      const legendX = paddingLeft + plotW + 8;
      const legendY = paddingTop;
      const legendH = plotH;
      const legendW = 12;

      for (let i = 0; i < legendH; i++) {
        const t = i / (legendH - 1);
        const tauVal = maxTau - t * (maxTau - minTau);
        const norm = (tauVal - minTau) / (maxTau - minTau);
        const h = (1 - norm) * 240;
        ctx.fillStyle = `hsl(${h}, 80%, 50%)`;
        ctx.fillRect(legendX, legendY + i, legendW, 1);
      }
      ctx.strokeStyle = "rgba(148,163,184,0.8)";
      ctx.strokeRect(legendX, legendY, legendW, legendH);

      ctx.fillStyle = "rgba(148,163,184,0.9)";
      const tauTicks = 4;
      for (let i = 0; i <= tauTicks; i++) {
        const t = i / tauTicks;
        const y = legendY + t * legendH;
        const tauVal = maxTau - t * (maxTau - minTau);
        ctx.beginPath();
        ctx.moveTo(legendX + legendW, y);
        ctx.lineTo(legendX + legendW + 3, y);
        ctx.stroke();
        ctx.fillText(tauVal.toFixed(1) + "%", legendX + legendW + 6, y + 3);
      }
      ctx.fillText("τ", legendX + legendW + 6, legendY - 10);

      const legendPointY = legendY + legendH + 16;
      const legendPointX = legendX;
      ctx.beginPath();
      ctx.arc(legendPointX + 6, legendPointY, 4, 0, 2 * Math.PI);
      ctx.fillStyle = "#ffffff";
      ctx.fill();
      ctx.lineWidth = 1;
      ctx.strokeStyle = "rgba(0,0,0,0.8)";
      ctx.stroke();
      ctx.fillStyle = "rgba(148,163,184,0.9)";
      ctx.fillText("(q, f)", legendPointX + 16, legendPointY + 3);

      const tauLevels = [];
      const nIso = 5;
      for (let i = 1; i <= nIso; i++) {
        const frac = i / (nIso + 1);
        const val = minTau + frac * (maxTau - minTau);
        tauLevels.push(val);
      }

      ctx.lineWidth = 1;
      tauLevels.forEach((tauLevel, idx) => {
        const tauDecLevel = tauLevel / 100;
        ctx.beginPath();
        let started = false;
        const steps = 200;
        const gray = 200 + idx * 10;
        ctx.strokeStyle = `rgba(${gray},${gray},${gray},0.8)`;
        for (let i = 0; i <= steps; i++) {
          const qVal = qMin + (i / steps) * (qMax - qMin);
          const denom = qVal * rhoLawDec;
          if (denom <= 0) continue;
          let fVal = 1 - (tauDecLevel * (1 + gammaDec * qVal)) / denom;
          if (fVal < fMin || fVal > fMax) {
            started = false;
            continue;
          }
          const x = paddingLeft + ((qVal - qMin) / (qMax - qMin)) * plotW;
          const y = paddingTop + (1 - (fVal - fMin) / (fMax - fMin)) * plotH;
          if (!started) {
            ctx.moveTo(x, y);
            started = true;
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.stroke();
      });

      const rhoLawDecSafe = rhoLawDec;
      if (useTauOv && rhoLawDecSafe > 0) {
        const tauDecOv = tauOverrideVal / 100;
        ctx.strokeStyle = "white";
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        let started = false;
        const steps = 300;
        for (let i = 0; i <= steps; i++) {
          const qVal = qMin + (i / steps) * (qMax - qMin);
          const denom = qVal * rhoLawDecSafe;
          if (denom <= 0) continue;
          let fVal = 1 - (tauDecOv * (1 + gammaDec * qVal)) / denom;
          if (fVal < fMin || fVal > fMax) {
            started = false;
            continue;
          }
          const x = paddingLeft + ((qVal - qMin) / (qMax - qMin)) * plotW;
          const y = paddingTop + (1 - (fVal - fMin) / (fMax - fMin)) * plotH;
          if (!started) {
            ctx.moveTo(x, y);
            started = true;
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.stroke();
      }

      if (qCurr >= qMin && qCurr <= qMax && fCurr >= fMin && fCurr <= fMax) {
        const xP = paddingLeft + ((qCurr - qMin) / (qMax - qMin)) * plotW;
        const yP = paddingTop + (1 - (fCurr - fMin) / (fMax - fMin)) * plotH;
        ctx.beginPath();
        ctx.arc(xP, yP, 6, 0, 2 * Math.PI);
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fill();
        ctx.beginPath();
        ctx.arc(xP, yP, 4, 0, 2 * Math.PI);
        ctx.fillStyle = "#ffffff";
        ctx.fill();
        ctx.lineWidth = 1;
        ctx.strokeStyle = "rgba(0,0,0,0.8)";
        ctx.stroke();
      }
    }

    function drawDynamicsChart(times, qSeries, tauSeries) {
      const ctx = qDynCanvas.getContext("2d");
      const width = qDynCanvas.clientWidth;
      const height = qDynCanvas.clientHeight;
      qDynCanvas.width = width * window.devicePixelRatio;
      qDynCanvas.height = height * window.devicePixelRatio;
      ctx.setTransform(window.devicePixelRatio, 0, 0, window.devicePixelRatio, 0, 0);

      ctx.clearRect(0, 0, width, height);

      if (!times.length) return;

      const paddingLeft = 45;
      const paddingRight = 45;
      const paddingTop = 20;
      const paddingBottom = 30;

      const plotW = width - paddingLeft - paddingRight;
      const plotH = height - paddingTop - paddingBottom;
      if (plotW <= 0 || plotH <= 0) return;

      let minQ = Math.min(...qSeries);
      let maxQ = Math.max(...qSeries);
      if (!isFinite(minQ) || !isFinite(maxQ)) return;
      if (maxQ === minQ) {
        minQ *= 0.9;
        maxQ *= 1.1;
      }

      let minTau = Math.min(...tauSeries);
      let maxTau = Math.max(...tauSeries);
      if (!isFinite(minTau) || !isFinite(maxTau)) {
        minTau = 0;
        maxTau = 30;
      }
      if (maxTau === minTau) {
        minTau *= 0.9;
        maxTau *= 1.1;
      }

      const T = times[times.length - 1];

      ctx.strokeStyle = "rgba(148,163,184,0.8)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(paddingLeft, paddingTop);
      ctx.lineTo(paddingLeft, paddingTop + plotH);
      ctx.lineTo(paddingLeft + plotW, paddingTop + plotH);
      ctx.stroke();

      ctx.fillStyle = "rgba(148,163,184,0.9)";
      ctx.font = "10px system-ui";

      const xTicks = Math.min(5, T || 1);
      for (let i = 0; i <= xTicks; i++) {
        const tVal = (T * i) / xTicks;
        const x = paddingLeft + (T === 0 ? 0 : (tVal / T) * plotW);
        const y = paddingTop + plotH;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x, y + 4);
        ctx.stroke();
        ctx.fillText(tVal.toFixed(0), x - 4, y + 14);
      }
      ctx.fillText("Jahre", paddingLeft + plotW / 2 - 15, paddingTop + plotH + 26);

      const yTicks = 4;
      for (let i = 0; i <= yTicks; i++) {
        const frac = i / yTicks;
        const qVal = minQ + (1 - frac) * (maxQ - minQ);
        const y = paddingTop + frac * plotH;
        ctx.beginPath();
        ctx.moveTo(paddingLeft - 4, y);
        ctx.lineTo(paddingLeft, y);
        ctx.stroke();
        ctx.fillText(qVal.toFixed(2), paddingLeft - 34, y + 3);
      }
      ctx.save();
      ctx.translate(paddingLeft - 40, paddingTop + plotH / 2 + 10);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText("q(t) = N_R/N_C", 0, 0);
      ctx.restore();

      for (let i = 0; i <= yTicks; i++) {
        const frac = i / yTicks;
        const tauVal = minTau + (1 - frac) * (maxTau - minTau);
        const y = paddingTop + frac * plotH;
        const x = paddingLeft + plotW;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + 4, y);
        ctx.stroke();
        ctx.fillText(tauVal.toFixed(1) + "%", x + 6, y + 3);
      }
      ctx.save();
      ctx.translate(paddingLeft + plotW + 38, paddingTop + plotH / 2 + 10);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText("τ(t) [%]", 0, 0);
      ctx.restore();

      ctx.beginPath();
      for (let i = 0; i < times.length; i++) {
        const t = times[i];
        const q = qSeries[i];
        const x = paddingLeft + (T === 0 ? 0 : (t / T) * plotW);
        const y = paddingTop + ((maxQ - q) / (maxQ - minQ)) * plotH;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.strokeStyle = "rgba(56,189,248,0.9)";
      ctx.lineWidth = 1.8;
      ctx.stroke();

      ctx.beginPath();
      for (let i = 0; i < times.length; i++) {
        const t = times[i];
        const tau = tauSeries[i];
        const x = paddingLeft + (T === 0 ? 0 : (t / T) * plotW);
        const y = paddingTop + ((maxTau - tau) / (maxTau - minTau)) * plotH;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.strokeStyle = "rgba(250,204,21,0.9)";
      ctx.lineWidth = 1.4;
      ctx.stroke();

      const xLast = paddingLeft + plotW;
      const qLast = qSeries[qSeries.length - 1];
      const tauLast = tauSeries[tauSeries.length - 1];
      const yLastQ = paddingTop + ((maxQ - qLast) / (maxQ - minQ)) * plotH;
      const yLastTau = paddingTop + ((maxTau - tauLast) / (maxTau - minTau)) * plotH;

      ctx.beginPath();
      ctx.arc(xLast, yLastQ, 4, 0, 2 * Math.PI);
      ctx.fillStyle = "#fff";
      ctx.fill();
      ctx.strokeStyle = "rgba(0,0,0,0.7)";
      ctx.lineWidth = 1;
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(xLast, yLastTau, 4, 0, 2 * Math.PI);
      ctx.fillStyle = "#fff";
      ctx.fill();
      ctx.strokeStyle = "rgba(0,0,0,0.7)";
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    function updateDynamics(NC0, NR0, W, rhoDec, fDec, gammaDec) {
      const T = Number(Tdyn.value);
      const gC = Number(gCSlider.value) / 100;
      const gR = Number(gRSlider.value) / 100;
      const M = Number(Mdyn.value);

      TdynLabel.textContent = T.toFixed(0) + " a";
      gCLabel.textContent   = (gC * 100).toFixed(1) + " %";
      gRLabel.textContent   = (gR * 100).toFixed(1) + " %";
      MLabel.textContent    = M.toFixed(2) + " Mio/a";

      let NC = NC0;
      let NR = NR0;

      const times = [];
      const qSeries = [];
      const tauSeries = [];

      let AEnd_bn = NaN;
      let SEnd_bn = NaN;
      let tauEndPct = NaN;
      let qEnd = NaN;

      for (let t = 0; t <= T; t++) {
        const q = NR / NC;
        const L = (NC + gammaDec * NR) * 1e6 * W;
        const A = NR * 1e6 * rhoDec * W;
        const tauDec = (q * rhoDec * (1 - fDec)) / (1 + gammaDec * q);
        const B = tauDec * L;
        const S = A - B;

        const A_bn = A / 1e9;
        const S_bn = S / 1e9;
        const tauPct = tauDec * 100;

        times.push(t);
        qSeries.push(q);
        tauSeries.push(tauPct);

        if (t === T) {
          AEnd_bn = A_bn;
          SEnd_bn = S_bn;
          tauEndPct = tauPct;
          qEnd = q;
        }

        NC = NC * (1 + gC) + M;
        NR = NR * (1 + gR);
      }

      drawDynamicsChart(times, qSeries, tauSeries);

      qEndOut.textContent   = fmtRat(qEnd);
      tauEndOut.textContent = fmtPct(tauEndPct);
      AEndOut.textContent   = fmtBn(AEnd_bn);
      SEndOut.textContent   = fmtBn(SEnd_bn);
    }

    function update() {
      const NC = Number(nc.value);
      const NR = Number(nr.value);
      const Wk = Number(w.value);
      const rhoPct = Number(rho.value);
      const fPct   = Number(f.value);
      const gammaPct = Number(gamma.value);

      const W = Wk * 1000;
      const q  = NR / NC;
      const rhoDec = rhoPct / 100;
      const fDec   = fPct / 100;
      const gammaDec = gammaPct / 100;

      const sDec = Number(sPriv.value) / 100;
      const rDec = Number(rPriv.value) / 100;
      const Tc = Number(TcPriv.value);
      const Tr = Number(TrPriv.value);

      let rhoPrivDec = 0;
      let K = 0;
      let Ppriv = 0;

      if (sDec > 0 && Tc > 0 && Tr > 0) {
        if (rDec > 0) {
          const num = Math.pow(1 + rDec, Tc) - 1;
          const den = 1 - Math.pow(1 + rDec, -Tr);
          if (den > 0) {
            const factor = num / den;
            rhoPrivDec = sDec * factor;
            K = sDec * W * ((Math.pow(1 + rDec, Tc) - 1) / rDec);
            Ppriv = K * (rDec / (1 - Math.pow(1 + rDec, -Tr)));
          }
        } else {
          K = sDec * W * Tc;
          Ppriv = K / Tr;
          rhoPrivDec = Ppriv / W;
        }
      }

      const rhoPrivPct = rhoPrivDec * 100;
      const rhoTotPct = (rhoDec + rhoPrivDec) * 100;

      const L = (NC + gammaDec * NR) * 1e6 * W;

      const A = NR * 1e6 * rhoDec * W;
      const tauDec_model = (q * rhoDec * (1 - fDec)) / (1 + gammaDec * q);
      const tauPct_model = tauDec_model * 100;

      const tauOverrideVal = tauOv.value === "" ? null : Number(tauOv.value);
      const useTauOv = tauOverrideVal !== null && !Number.isNaN(tauOverrideVal);

      let B_actual = tauDec_model * L;
      let S_actual = A - B_actual;
      let fImplPct = fPct;

      if (useTauOv) {
        const tauOvDec = tauOverrideVal / 100;
        B_actual = tauOvDec * L;
        S_actual = A - B_actual;
        const fImpl = S_actual / A;
        fImplPct = fImpl * 100;
      }

      const A_bn = A / 1e9;
      const B_bn = B_actual / 1e9;
      const S_bn = S_actual / 1e9;

      ncLabel.textContent  = NC + " Mio";
      nrLabel.textContent  = NR + " Mio";
      wLabel.textContent   = Wk.toFixed(0) + " k€";
      rhoLabel.textContent = rhoPct.toFixed(0) + " %";
      fLabel.textContent   = fPct.toFixed(0) + " %";
      gammaLabel.textContent = gammaPct.toFixed(0) + " %";
      tauOvLbl.textContent = useTauOv ? tauOverrideVal.toFixed(1) + " %" : "auto";

      sPrivLabel.textContent  = (sDec * 100).toFixed(0) + " %";
      rPrivLabel.textContent  = (rDec * 100).toFixed(2) + " %";
      TcPrivLabel.textContent = Tc.toFixed(0) + " a";
      TrPrivLabel.textContent = Tr.toFixed(0) + " a";

      tauOut.textContent = fmtPct(tauPct_model);
      fOut.textContent   = useTauOv ? fmtPct(fImplPct) : fmtPct(fPct);
      AOut.textContent   = fmtBn(A_bn);
      BOut.textContent   = fmtBn(B_bn);
      SOut.textContent   = fmtBn(S_bn);
      qOut.textContent   = fmtRat(q);

      rhoGesOut.textContent  = fmtPct(rhoPct);
      rhoPrivOut.textContent = fmtPct(rhoPrivPct);
      rhoTotOut.textContent  = fmtPct(rhoTotPct);

      PprivOut.textContent   = fmtK(Ppriv / 1000);
      KprivOut.textContent   = fmtK(K / 1000);

      drawContour();
      updateDynamics(NC, NR, W, rhoDec, fDec, gammaDec);
    }

    [
      nc, nr, w, rho, f, gamma, tauOv,
      sPriv, rPriv, TcPriv, TrPriv,
      Tdyn, gCSlider, gRSlider, Mdyn
    ].forEach(el => {
      el.addEventListener("input", update);
      el.addEventListener("change", update);
    });

    document.querySelectorAll(".scenario-btn").forEach(btn => {
      btn.addEventListener("click", (e) => {
        const scenario = e.target.getAttribute("data-scenario");
        document.querySelectorAll(".scenario-btn").forEach(b => b.classList.remove("primary"));
        e.target.classList.add("primary");
        applyScenario(scenario);
      });
    });

    exportChartBtn.addEventListener("click", () => {
      const url = contourCanvas.toDataURL("image/png");
      const link = document.createElement("a");
      link.href = url;
      link.download = "rentenmodell_contour.png";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    });

    applyScenario("statusQuoDE");
  </script>
</body>
</html>
